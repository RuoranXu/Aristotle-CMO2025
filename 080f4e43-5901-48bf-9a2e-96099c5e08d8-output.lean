/-
Sorry, Aristotle was unable to complete the task in time.
-/
/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
-/

import Mathlib

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
We define the elementary symmetric polynomials e1, e2, e3 and the condition given in the problem, using 'c' for the parameter lambda.
-/
open BigOperators


def e1 {n : ℕ} (x : Fin n → ℝ) : ℝ := ∑ i, x i

def e2 {n : ℕ} (x : Fin n → ℝ) : ℝ := ∑ i, ∑ j, if i < j then x i * x j else 0

def e3 {n : ℕ} (x : Fin n → ℝ) : ℝ := ∑ i, ∑ j, ∑ k, if i < j ∧ j < k then x i * x j * x k else 0

def satisfies_cond (n : ℕ) (c : ℝ) (x : Fin n → ℝ) : Prop :=
  e1 x = 1 ∧
  (e2 x)^2 ≤ c * e3 x - (1 / (n : ℝ)) * (∑ i, ∑ j, if i < j then (x i - x j)^2 else 0)

/-
We prove the identity for the sum of squared differences.
-/
lemma sum_sq_diff_eq {n : ℕ} (x : Fin n → ℝ) :
  (∑ i, ∑ j, if i < j then (x i - x j)^2 else 0) = n * (∑ i, (x i)^2) - (∑ i, x i)^2 := by
    induction' n with n ih;
    · -- The sum over an empty set is zero.
      simp [Finset.sum_empty];
    · specialize ih ( x ∘ Fin.succ ) ; simp_all +decide [ Fin.sum_univ_succ ];
      simp +decide [ sub_sq, Finset.sum_add_distrib, Finset.mul_sum _ _ _ ] ; ring;
      simpa [ Finset.mul_sum _ _ _, Finset.sum_mul ] using by ring;

/-
We prove the identity relating e2 to e1 and the sum of squares.
-/
lemma e2_eq {n : ℕ} (x : Fin n → ℝ) :
  e2 x = ((e1 x)^2 - (∑ i, (x i)^2)) / 2 := by
    unfold e2 e1;
    induction' n with n ih <;> simp +decide [ Fin.sum_univ_succ, * ] ; ring;
    simpa only [ ← Finset.mul_sum _ _ _, ih ] using by ring;

/-
We simplify the condition to (1 - e2)^2 - 1/n ≤ c * e3.
-/
lemma condition_simplified {n : ℕ} {c : ℝ} {x : Fin n → ℝ} (h1 : e1 x = 1) (hn : n ≠ 0) :
  satisfies_cond n c x ↔ (1 - e2 x)^2 - (1 / (n : ℝ)) ≤ c * e3 x := by
    aesop;
    · -- Substitute the identity for sum_sq_diff_eq x into the inequality from a.
      have h_sub : e2 x^2 ≤ c * e3 x - (1 / n) * (n * (1 - 2 * e2 x) - 1) := by
        convert a.2 using 1;
        rw [ sum_sq_diff_eq, e2_eq, h1 ] ; ring;
        unfold e1 at h1 ; aesop;
      -- Simplify the right-hand side of h_sub.
      field_simp at h_sub;
      nlinarith [ inv_pos.mpr ( by positivity : 0 < ( n : ℝ ) ), mul_inv_cancel₀ ( by positivity : ( n : ℝ ) ≠ 0 ) ];
    · constructor <;> aesop;
      -- Substitute the identity for the sum of squared differences into the inequality.
      have h_sum_sq_diff : ∑ i, ∑ j, (if i < j then (x i - x j) ^ 2 else 0) = n * (∑ i, (x i) ^ 2) - 1 := by
        -- Apply the identity for the sum of squared differences.
        have h_sum_sq_diff : ∑ i, ∑ j, (if i < j then (x i - x j)^2 else 0) = n * ∑ i, x i^2 - (∑ i, x i)^2 := by
          exact?;
        unfold e1 at h1; aesop;
      -- Substitute the identity for e2 into the inequality.
      have h_e2 : e2 x = (1 - ∑ i, (x i) ^ 2) / 2 := by
        convert e2_eq x using 1;
        -- Substitute h1 into the right-hand side to get (1^2 - ∑ i, x i^2) / 2, which simplifies to (1 - ∑ i, x i^2) / 2.
        rw [h1]
        norm_num;
      nlinarith [ inv_pos.mpr ( by positivity : 0 < ( n : ℝ ) ), mul_inv_cancel₀ ( by positivity : ( n : ℝ ) ≠ 0 ) ]

/-
We define the uniform vector x_uniform where each component is 1/n, and show that e1(x_uniform) = 1.
-/
def x_uniform (n : ℕ) : Fin n → ℝ := fun _ => 1 / (n : ℝ)

lemma e1_uniform {n : ℕ} (hn : n ≠ 0) : e1 (x_uniform n) = 1 := by
  -- By definition of $e1$, we have $e1(x_uniform n) = \sum_{i=1}^n x_uniform n i$.
  have h_e1 : e1 (x_uniform n) = ∑ i : Fin n, (1 / (n : ℝ)) := by
    exact Finset.sum_congr rfl fun _ _ => rfl;
  aesop

/-
We calculate e2 for the uniform vector.
-/
lemma e2_uniform {n : ℕ} (hn : n ≠ 0) : e2 (x_uniform n) = (1 - 1 / (n : ℝ)) / 2 := by
  -- Substitute the known values of e1(x_uniform n) and the sum of squares into the expression for e2(x_uniform n).
  have h_e2_uniform : e2 (x_uniform n) = (1^2 - ∑ i : Fin n, (1 / (n : ℝ))^2) / 2 := by
    rw [ e2_eq ];
    congr;
    exact e1_uniform hn;
  -- Simplify the sum $\sum_{i=0}^{n-1} (1/n)^2$ to $n \cdot (1/n)^2 = 1/n$.
  have h_sum : ∑ i : Fin n, (1 / (n : ℝ))^2 = 1 / (n : ℝ) := by
    norm_num [ sq, hn ];
  grind

/-
We calculate e3 for the uniform vector.
-/
lemma e3_uniform {n : ℕ} (hn : n ≠ 0) : e3 (x_uniform n) = (n - 1) * (n - 2) / (6 * n^2) := by
  -- The number of ways to choose 3 distinct indices from n is given by the combination formula C(n, 3), which is n(n-1)(n-2)/6.
  have h_comb : ∑ i : Fin n, ∑ j : Fin n, ∑ k : Fin n, (if i < j ∧ j < k then (1 / (n : ℝ)) * (1 / (n : ℝ)) * (1 / (n : ℝ)) else 0) = (Nat.choose n 3 : ℝ) * (1 / (n : ℝ)) ^ 3 := by
    -- The number of ways to choose 3 distinct indices from n is given by the combination formula C(n, 3), which is n(n-1)(n-2)/6. Each term in the sum is (1/n)^3, so the total sum is C(n, 3) * (1/n)^3.
    have h_comb : ∑ i : Fin n, ∑ j : Fin n, ∑ k : Fin n, (if i < j ∧ j < k then 1 else 0) = Nat.choose n 3 := by
      induction' n with n ih;
      · grind +ring;
      · simp +decide [ Fin.sum_univ_succ, Nat.choose_succ_succ ];
        congr 1;
        · simp +decide [ Finset.filter_lt_eq_Ioi ];
          exact Eq.symm ( Nat.recOn n ( by norm_num ) fun n ih => by cases n <;> simp +decide [ Nat.choose, Fin.sum_univ_succ ] at * ; linarith );
        · by_cases hn : n = 0 <;> aesop;
          convert ih using 3;
          rw [ Finset.card_filter, Finset.card_filter ];
          rw [ Fin.sum_univ_succ ] ; aesop;
    simp +decide [ ← h_comb, Finset.sum_ite ] ; ring;
    simp +decide only [mul_comm, Finset.mul_sum _ _ _];
  convert h_comb using 1;
  rcases n with ( _ | _ | _ | n ) <;> norm_num [ Nat.succ_mul_choose_eq ] at *;
  rw [ Nat.cast_choose ] <;> norm_num;
  -- Simplify the right-hand side of the equation.
  field_simp [Nat.factorial_succ, Nat.factorial_succ, Nat.factorial_succ]
  ring;
  norm_num [ Nat.add_comm 3, Nat.factorial_succ ] ; ring

/-
We define the validity of a parameter c and the solution set.
-/
def is_valid_lambda (c : ℝ) : Prop :=
  ∃ N, ∀ n ≥ N, ∃ x : Fin n → ℝ, satisfies_cond n c x

def solution_set : Set ℝ := { c | is_valid_lambda c }

/-
A quadratic polynomial in n with positive leading coefficient is eventually non-negative.
-/
lemma quadratic_pos_of_leading_coeff_pos {a b c : ℝ} (ha : a > 0) :
  ∀ᶠ n : ℕ in Filter.atTop, a * (n : ℝ)^2 + b * (n : ℝ) + c ≥ 0 := by
    simp +zetaDelta at *;
    exact ⟨ Nat.ceil ( |b| / a + |c| / a + 1 ), fun n hn => by cases abs_cases b <;> cases abs_cases c <;> nlinarith [ Nat.ceil_le.mp hn, mul_div_cancel₀ ( |b| : ℝ ) ha.ne', mul_div_cancel₀ ( |c| : ℝ ) ha.ne', mul_nonneg ha.le ( Nat.cast_nonneg n ) ] ⟩

/-
We prove that e2(x_uniform n) tends to 1/2 as n goes to infinity.
-/
open BigOperators Filter Topology

lemma tendsto_e2_uniform : Tendsto (fun n : ℕ => e2 (x_uniform n)) atTop (nhds (1/2 : ℝ)) := by
  have h_e2_uniform : ∀ n : ℕ, n ≠ 0 → e2 (x_uniform n) = (1 - 1 / (n : ℝ)) / 2 := by
    exact?;
  rw [ Filter.tendsto_congr' ( by filter_upwards [ Filter.eventually_ne_atTop 0 ] with n hn; rw [ h_e2_uniform n hn ] ) ] ; exact le_trans ( Filter.Tendsto.div_const ( tendsto_const_nhds.sub ( tendsto_one_div_atTop_nhds_zero_nat ) ) _ ) ( by norm_num ) ;

/-
We prove that e2(x_uniform n) tends to 1/2 as n goes to infinity.
-/
open BigOperators Filter Topology

lemma tendsto_e2_uniform_val : Tendsto (fun n : ℕ => e2 (x_uniform n)) atTop (nhds (1/2 : ℝ)) := by
  exact?

/-
We prove that e3(x_uniform n) tends to 1/6 as n goes to infinity.
-/
open BigOperators Filter Topology

lemma tendsto_e3_uniform : Tendsto (fun n : ℕ => e3 (x_uniform n)) atTop (nhds (1/6 : ℝ)) := by
  -- We can simplify the expression for e3(x_uniform n) as n approaches infinity.
  have h_simplify : Filter.Tendsto (fun n : ℕ => (1 - 3 / (n : ℝ) + 2 / (n ^ 2 : ℝ)) / 6) Filter.atTop (nhds (1 / 6)) := by
    ring_nf;
    simpa using Filter.Tendsto.add ( tendsto_const_nhds.add ( tendsto_inverse_atTop_nhds_zero_nat.mul_const _ ) ) ( tendsto_inverse_atTop_nhds_zero_nat.pow 2 |> Filter.Tendsto.mul_const _ );
  refine h_simplify.congr' ?_ ; filter_upwards [ Filter.eventually_gt_atTop 0 ] with n hn ; erw [ show e3 ( x_uniform n ) = ( ( n - 1 ) * ( n - 2 ) : ℝ ) / ( 6 * n ^ 2 ) by exact ( e3_uniform <| by positivity ) ] ; ring ; aesop;
  -- Combine like terms and simplify the expression.
  field_simp
  ring

/-
We prove that any c > 1.5 is valid.
We show that the condition is satisfied by the uniform distribution for sufficiently large n.
We use the fact that the LHS of the condition tends to 1/4 and the RHS tends to c/6.
Since c > 1.5, c/6 > 1/4, so eventually LHS < RHS.
-/
open BigOperators Filter Topology

lemma valid_of_gt_1_5 {c : ℝ} (h : c > 3/2) : is_valid_lambda c := by
  -- Since $c > 3/2$, we have $c/6 > 1/4$. Therefore, there exists an $N$ such that for all $n \geq N$, the condition holds.
  have h_exists_N : ∃ N : ℕ, ∀ n ≥ N, (1 - e2 (x_uniform n))^2 - (1 / (n : ℝ)) ≤ c * e3 (x_uniform n) := by
    -- We'll use the fact that as $n$ grows large, $(1 - e2 (x_uniform n))^2 - (1 / (n : ℝ))$ tends to $1/4$ and $c * e3 (x_uniform n)$ tends to $c/6$.
    have h_tendsto : Filter.Tendsto (fun n : ℕ => (1 - e2 (x_uniform n))^2 - (1 / (n : ℝ))) Filter.atTop (nhds (1 / 4)) ∧ Filter.Tendsto (fun n : ℕ => c * e3 (x_uniform n)) Filter.atTop (nhds (c / 6)) := by
      -- We'll use the fact that $e2(x_uniform n)$ tends to $1/2$ and $e3(x_uniform n)$ tends to $1/6$ as $n$ goes to infinity.
      have h_e2 : Filter.Tendsto (fun n : ℕ => e2 (x_uniform n)) Filter.atTop (nhds (1 / 2)) := by
        convert tendsto_e2_uniform_val using 1
      have h_e3 : Filter.Tendsto (fun n : ℕ => e3 (x_uniform n)) Filter.atTop (nhds (1 / 6)) := by
        exact?;
      exact ⟨ by convert Filter.Tendsto.sub ( Filter.Tendsto.pow ( tendsto_const_nhds.sub h_e2 ) 2 ) ( tendsto_one_div_atTop_nhds_zero_nat ) using 2 ; norm_num, by convert tendsto_const_nhds.mul h_e3 using 2 ; norm_num ; ring ⟩;
    have := h_tendsto.1.sub h_tendsto.2;
    have := this.eventually ( gt_mem_nhds <| show 1 / 4 - c / 6 < 0 by linarith ) ; aesop;
    exact ⟨ w, fun n hn => by linarith [ h_1 n hn ] ⟩;
  exact ⟨ h_exists_N.choose + 2, fun n hn => ⟨ x_uniform n, condition_simplified ( show e1 ( x_uniform n ) = 1 from e1_uniform ( by norm_num; linarith ) ) ( by norm_num; linarith ) |>.2 <| h_exists_N.choose_spec n ( by linarith ) ⟩ ⟩

/-
I prove that the sum of squares is positive if the sum is 1.
-/
lemma p2_pos {n : ℕ} {x : Fin n → ℝ} (h1 : e1 x = 1) (hn : n ≠ 0) : ∑ i, (x i)^2 > 0 := by
  -- If the sum of squares were zero, then each $x_i$ would be zero, contradicting $e1 x = 1$.
  by_contra h_contra
  have h_all_zero : ∀ i, x i = 0 := by
    exact fun i => sq_eq_zero_iff.mp ( le_antisymm ( le_of_not_gt fun hi => h_contra <| hi.trans_le <| Finset.single_le_sum ( fun i _ => sq_nonneg <| x i ) <| Finset.mem_univ i ) <| sq_nonneg <| x i );
  unfold e1 at h1; aesop;

/-
I define S2 and S3 and prove the identity relating e3 to S2 and S3.
-/
def S2 {n : ℕ} (x : Fin n → ℝ) : ℝ := ∑ i, (x i)^2
def S3 {n : ℕ} (x : Fin n → ℝ) : ℝ := ∑ i, (x i)^3

lemma e3_eq_S2_S3 {n : ℕ} (x : Fin n → ℝ) (h1 : e1 x = 1) :
  6 * e3 x = 1 - 3 * S2 x + 2 * S3 x := by
    -- Using the identity for e3 in terms of S1, S2, and S3, we have e3 = (S1^3 - 3S1S2 + 2S3)/6.
    have h_e3_identity : e3 x = (1^3 - 3 * 1 * S2 x + 2 * S3 x) / 6 := by
      rw [ ← h1 ];
      unfold e3 e1 S2 S3; ring;
      clear h1;
      induction' n with n ih <;> simp +decide [ Fin.sum_univ_succ, * ] ; ring;
      have h_sum_sq : ∀ (n : ℕ) (x : Fin n → ℝ), (∑ i : Fin n, x i)^2 = ∑ i : Fin n, x i^2 + 2 * ∑ i : Fin n, ∑ j : Fin n, if i < j then x i * x j else 0 := by
        intro n x; induction' n with n ih <;> simp +decide [ Fin.sum_univ_succ, * ] ; ring;
        simpa only [ ← Finset.mul_sum _ _ _, ih ] using by ring;
      rw [ h_sum_sq ] ; ring;
      simp +decide [ Finset.mul_sum _ _ _, mul_assoc, mul_left_comm, Finset.sum_mul ];
    linarith

#check valid_of_gt_1_5

/-
I prove that S3 is bounded by S2^(3/2). I explicitly type `3/2` as `ℝ`.
-/
lemma S3_le_S2_pow_3_2 {n : ℕ} (x : Fin n → ℝ) : S3 x ≤ (S2 x)^(3/2 : ℝ) := by
  -- For each $i$, we have $x_i^3 \leq x_i^2 \cdot |x_i|$. Since $|x_i| \leq \sqrt{S2 x}$, we get $x_i^3 \leq x_i^2 \cdot \sqrt{S2 x}$.
  have h_term_bound : ∀ i, x i ^ 3 ≤ x i ^ 2 * Real.sqrt (S2 x) := by
    -- Since $|x_i| \leq \sqrt{S2 x}$, we have $x_i^3 \leq x_i^2 \cdot \sqrt{S2 x}$.
    have h_abs : ∀ i, |x i| ≤ Real.sqrt (S2 x) := by
      exact fun i => Real.abs_le_sqrt <| Finset.single_le_sum ( fun i _ => sq_nonneg <| x i ) <| Finset.mem_univ i;
    exact fun i => by cases abs_cases ( x i ) <;> nlinarith [ h_abs i ] ;
  convert Finset.sum_le_sum fun i _ => h_term_bound i using 1 ; ring;
  rw [ ← Finset.sum_mul _ _ _, show S2 x ^ ( 3 / 2 : ℝ ) = S2 x * Real.sqrt ( S2 x ) by rw [ Real.sqrt_eq_rpow, ← Real.rpow_one_add' ] <;> norm_num ; exact Finset.sum_nonneg fun _ _ => sq_nonneg _ ];
  rfl

/-
I define the polynomial P and prove that the condition implies P(sqrt(S2), c) ≤ 12/n. I use `c` instead of `λ` to avoid syntax errors.
-/
def poly_P (y c : ℝ) : ℝ := 3 * y^4 - 4 * c * y^3 + (6 * c + 6) * y^2 + 3 - 2 * c

lemma condition_implies_poly_le {n : ℕ} {c : ℝ} {x : Fin n → ℝ} (h_cond : satisfies_cond n c x) (hc_nonneg : c ≥ 0) (hn : n ≠ 0) :
  poly_P (Real.sqrt (S2 x)) c ≤ 12 / n := by
    -- Substitute the identity for e3 x into the condition.
    have h_sub : (1 - e2 x)^2 - 1 / (n : ℝ) ≤ c * (1 - 3 * S2 x + 2 * S3 x) / 6 := by
      -- Substitute the identity for e3 x into the condition from h_cond.
      have h_sub : (1 - e2 x)^2 - 1 / (n : ℝ) ≤ c * (6 * e3 x) / 6 := by
        rw [ condition_simplified ] at h_cond <;> aesop;
        · linarith;
        · exact h_cond.1;
      convert h_sub using 2 ; rw [ e3_eq_S2_S3 ];
      exact h_cond.1;
    -- Substitute h_e2 into h_sub and simplify.
    have h_sub_simplified : (1 + S2 x)^2 / 4 - 1 / (n : ℝ) ≤ c * (1 - 3 * S2 x + 2 * S2 x * Real.sqrt (S2 x)) / 6 := by
      convert h_sub.trans _ using 1;
      · rw [ e2_eq ];
        rw [ show e1 x = 1 from h_cond.1 ] ; ring;
        ring!;
      · have := S3_le_S2_pow_3_2 x; rw [ show ( S2 x : ℝ ) ^ ( 3 / 2 : ℝ ) = S2 x * Real.sqrt ( S2 x ) by rw [ Real.sqrt_eq_rpow, ← Real.rpow_one_add' ] <;> norm_num ; exact Finset.sum_nonneg fun _ _ => sq_nonneg _ ] at this; nlinarith;
    norm_num [ poly_P ] at *;
    rw [ show ( Real.sqrt ( S2 x ) ) ^ 4 = ( Real.sqrt ( S2 x ) ^ 2 ) ^ 2 by ring, show ( Real.sqrt ( S2 x ) ) ^ 3 = ( Real.sqrt ( S2 x ) ) * ( Real.sqrt ( S2 x ) ^ 2 ) by ring, Real.sq_sqrt <| show 0 ≤ S2 x from Finset.sum_nonneg fun _ _ => sq_nonneg _ ] ; ring_nf at * ; nlinarith

/-
I prove that S2 x >= 1/n using Cauchy-Schwarz.
-/
lemma S2_ge_one_div_n {n : ℕ} {x : Fin n → ℝ} (h1 : e1 x = 1) (hn : n ≠ 0) : S2 x ≥ 1 / (n : ℝ) := by
  -- By Cauchy-Schwarz inequality, we have $(\sum_{i=1}^n x_i)^2 \leq n \sum_{i=1}^n x_i^2$.
  have h_cauchy_schwarz : (∑ i, (x i))^2 ≤ (n : ℝ) * (∑ i, (x i)^2) := by
    have := ( Finset.univ.sum_le_sum fun i _ => mul_self_nonneg ( x i - ( ∑ i : Fin n, x i ) / n ) );
    simp_all +decide [ add_mul, sub_mul, mul_sub ];
    case _ => simp_all +decide only [← Finset.sum_mul, ← sq, ← Finset.mul_sum _ _ _] ; nlinarith [ mul_div_cancel₀ ( ( ∑ i : Fin n, x i ) : ℝ ) ( Nat.cast_ne_zero.mpr hn ) ] ;
  simp +zetaDelta at *;
  -- Substitute h1 into the Cauchy-Schwarz inequality to get 1 ≤ n * S2 x.
  have h_subst : 1 ≤ n * S2 x := by
    unfold e1 at h1; aesop;
  rwa [ inv_eq_one_div, div_le_iff₀' ( by positivity ) ]

/-
I prove that P(y, c) ≥ 12 y^2 for c ≤ 3/2 and y ≥ 0. I use the factorization 4y^3 - 6y^2 + 2 = 2(y-1)^2(2y+1).
-/
lemma poly_P_ge_12_sq {y c : ℝ} (hc : c ≤ 3/2) (hy : y ≥ 0) : poly_P y c ≥ 12 * y^2 := by
  suffices poly_P y c - 12 * y^2 ≥ 0 by linarith
  have h_diff : poly_P y c - 12 * y^2 = 3 * y^2 * (y - 1)^2 + (3/2 - c) * (4 * y^3 - 6 * y^2 + 2) := by
    rw [poly_P]
    ring
  rw [h_diff]
  have h_fac : 4 * y^3 - 6 * y^2 + 2 = 2 * (y - 1)^2 * (2 * y + 1) := by ring
  rw [h_fac]
  have h_term1 : 3 * y^2 * (y - 1)^2 ≥ 0 := by positivity
  have h_term2 : (3/2 - c) * (2 * (y - 1)^2 * (2 * y + 1)) ≥ 0 := by
    apply mul_nonneg
    · linarith
    · apply mul_nonneg
      · positivity
      · linarith
  linarith

/-
I prove that if c ≤ 1.5, then S2 x must be exactly 1/n.
-/
lemma S2_eq_one_div_n_of_cond_le_1_5 {n : ℕ} {c : ℝ} {x : Fin n → ℝ} (h_cond : satisfies_cond n c x) (hc : c ≤ 3/2) (hc_nonneg : c ≥ 0) (hn : n ≠ 0) :
  S2 x = 1 / (n : ℝ) := by
    -- We have $P(\sqrt{S2 x}, c) \leq 12/n$ and $P(y, c) \geq 12y^2$ for $y \geq 0$ and $c \leq 3/2$.
    have h_poly_le : poly_P (Real.sqrt (S2 x)) c ≤ 12 / (n : ℝ) := by
      -- Apply the lemma that states if the condition holds, then poly_P (Real.sqrt (S2 x)) c ≤ 12 / n.
      apply condition_implies_poly_le h_cond hc_nonneg hn
    have h_poly_ge : poly_P (Real.sqrt (S2 x)) c ≥ 12 * (Real.sqrt (S2 x))^2 := by
      -- Apply the lemma that states $P(y, c) \geq 12y^2$ for $y \geq 0$ and $c \leq 3/2$.
      apply poly_P_ge_12_sq; exact hc; exact Real.sqrt_nonneg (S2 x);
    -- Combining the inequalities $12 * S2 x \leq 12 / n$ and $S2 x \geq 1 / n$, we get $S2 x = 1 / n$.
    have h_eq : S2 x ≤ 1 / (n : ℝ) ∧ S2 x ≥ 1 / (n : ℝ) := by
      aesop;
      · grind;
      · have := S2_ge_one_div_n ( show e1 x = 1 from h_cond.1 ) hn; aesop;
    linarith

/-
I prove that if c ≤ 1.5, then S2 x ≤ 1/n.
-/
lemma S2_le_one_div_n_of_cond_le_1_5 {n : ℕ} {c : ℝ} {x : Fin n → ℝ} (h_cond : satisfies_cond n c x) (hc : c ≤ 3/2) (hc_nonneg : c ≥ 0) (hn : n ≠ 0) :
  S2 x ≤ 1 / (n : ℝ) := by
    -- Apply the lemma that states S2 x equals 1/n under the given conditions.
    have h_S2_eq : S2 x = 1 / (n : ℝ) := by
      exact?;
    rw [h_S2_eq]

/-
I prove that if S2 x = 1/n and e1 x = 1, then x is the uniform vector.
-/
lemma x_eq_uniform_of_S2_eq_one_div_n {n : ℕ} {x : Fin n → ℝ} (h1 : e1 x = 1) (hn : n ≠ 0) (hS2 : S2 x = 1 / (n : ℝ)) :
  ∀ i, x i = 1 / (n : ℝ) := by
    -- By the equality condition of the QM-AM inequality, since S2 x = 1/n and e1 x = 1, all x_i must be equal.
    have h_eq : ∀ i j, x i = x j := by
      -- By the equality condition of the Cauchy-Schwarz inequality, since $(\sum x_i)^2 = n \sum x_i^2$, all $x_i$ must be equal.
      have h_cauchy_schwarz : (∑ i, (x i - (∑ i, x i) / n)^2) = 0 := by
        simp_all +decide [ sub_sq, Finset.sum_add_distrib, Finset.mul_sum _ _ _, Finset.sum_mul _ _ _ ];
        simp_all +decide [ ← Finset.mul_sum _ _ _, ← Finset.sum_mul, e1, S2 ];
        -- Combine like terms and simplify the expression.
        field_simp
        ring;
      rw [ Finset.sum_eq_zero_iff_of_nonneg fun _ _ => sq_nonneg _ ] at h_cauchy_schwarz ; aesop;
      linarith [ h_cauchy_schwarz i, h_cauchy_schwarz j ];
    unfold e1 at h1; aesop;
    exact eq_inv_of_mul_eq_one_right ( by have := Finset.sum_congr rfl fun j ( hj : j ∈ Finset.univ ) => h_eq j i; norm_num at *; nlinarith [ mul_inv_cancel₀ ( by positivity : ( n : ℝ ) ≠ 0 ) ] )

/-
I prove that if the uniform vector satisfies the condition, then 3(n-1) ≤ 2c(n-2).
-/
lemma uniform_satisfies_cond_imp_ineq {n : ℕ} {c : ℝ} (hn : n > 2) :
  satisfies_cond n c (x_uniform n) → 3 * ((n : ℝ) - 1) ≤ 2 * c * ((n : ℝ) - 2) := by
    -- Substitute the values of e2 and e3 for the uniform vector into the simplified condition.
    intro h_cond
    have h_e2 : e2 (x_uniform n) = (1 - 1 / (n : ℝ)) / 2 := by
      field_simp;
      rw [ show e2 ( x_uniform n ) = ( 1 - 1 / ( n : ℝ ) ) / 2 from e2_uniform ( by positivity ) ] ; ring_nf ; norm_num [ show n ≠ 0 by positivity ];
      ring
    have h_e3 : e3 (x_uniform n) = (n - 1) * (n - 2) / (6 * n^2) := by
      -- By definition of $x_uniform$, we know that $e3(x_uniform n) = \frac{(n-1)(n-2)}{6n^2}$.
      apply e3_uniform; exact Nat.ne_of_gt (by linarith);
    -- Substitute h_e2 and h_e3 into the simplified condition.
    have h_simplified : (1 - (1 - 1 / (n : ℝ)) / 2)^2 - 1 / (n : ℝ) ≤ c * ((n - 1) * (n - 2) / (6 * n^2)) := by
      -- Substitute h_e2 and h_e3 into the simplified condition to get the desired inequality.
      have h_simplified : (1 - e2 (x_uniform n))^2 - 1 / (n : ℝ) ≤ c * e3 (x_uniform n) := by
        -- Apply the condition_simplified lemma to h_cond, using the facts that e1 (x_uniform n) = 1 and n ≠ 0.
        apply (condition_simplified (e1_uniform (by linarith)) (by linarith)).mp h_cond;
      grind;
    field_simp at h_simplified;
    nlinarith [ ( by norm_cast : ( 3 : ℝ ) ≤ n ) ]

/-
I prove that if 0 ≤ c ≤ 1.5, then c is not valid.
I assume c is valid, pick a large n, show x must be uniform, and then derive a contradiction from the inequality satisfied by the uniform distribution.
-/
lemma not_valid_of_nonneg_le_1_5 {c : ℝ} (hc_nonneg : 0 ≤ c) (hc_le : c ≤ 3/2) : ¬ is_valid_lambda c := by
  intro h;
  -- Assume $c \leq 1.5$. Then for sufficiently large $n$, $x$ must be uniform.
  obtain ⟨N, hN⟩ := h
  obtain ⟨n, hnN, x, hx⟩ : ∃ n ≥ N, ∃ x : Fin n → ℝ, satisfies_cond n c x ∧ n > 2 := by
    exact ⟨ N + 3, by linarith, hN _ ( by linarith ) |> Classical.choose, hN _ ( by linarith ) |> Classical.choose_spec, by linarith ⟩;
  -- By the previous results, if $c \leq 1.5$, then $x$ must be the uniform vector.
  have hx_uniform : x = x_uniform n := by
    have hx_uniform : S2 x = 1 / (n : ℝ) := by
      -- Apply the lemma that states if the condition holds and c ≤ 1.5, then S2 x must be 1/n.
      apply S2_eq_one_div_n_of_cond_le_1_5 hx.left hc_le hc_nonneg (by linarith);
    exact funext fun i => x_eq_uniform_of_S2_eq_one_div_n ( by simpa using hx.1.1 ) ( by linarith ) hx_uniform i;
  have := uniform_satisfies_cond_imp_ineq hx.2 ( hx_uniform ▸ hx.1 );
  nlinarith [ show ( n : ℝ ) ≥ 3 by norm_cast; linarith ]

/-
I prove that -S3 x ≤ (S2 x)^(3/2) by applying the previous lemma to -x.
-/
lemma neg_S3_le_S2_pow_3_2 {n : ℕ} (x : Fin n → ℝ) : -S3 x ≤ (S2 x)^(3/2 : ℝ) := by
  -- By applying the lemma S3_le_S2_pow_3_2 to -x, we get S3 (-x) ≤ (S2 (-x))^(3/2).
  have h_neg : S3 (-x) ≤ (S2 (-x))^(3 / 2 : ℝ) := by
    exact?;
  convert h_neg using 1 <;> norm_num [ S2, S3 ];
  norm_num [ neg_pow, Finset.sum_neg_distrib ]

/-
I prove that c = -3 is valid by constructing a specific vector x.
I use the configuration x = (-sqrt(3), s, s, ...) where s is chosen to make e1=1.
This configuration yields S2 approx 3 and S3 approx -3sqrt(3), which satisfies the condition for c=-3.
-/
lemma is_valid_neg_3 : is_valid_lambda (-3) := by
  use 10
  intro n hn
  -- Construct x such that S2 is approx 3.
  -- Let s = (sqrt(3) - 1) / (n - 1).
  -- Let L = 1 + (n-1)s = sqrt(3).
  -- x = (-L, s, s, ...).
  -- e1 = -L + (n-1)s = -sqrt(3) + (sqrt(3)-1) = -1.
  -- Wait, I need e1 = 1.
  -- x = (L, -s, -s, ...).
  -- L - (n-1)s = 1 => L = 1 + (n-1)s.
  -- S2 = L^2 + (n-1)s^2 = (1+(n-1)s)^2 + (n-1)s^2.
  -- We want S2 = 3.
  -- (1+k)^2 = 3 (approx). k = sqrt(3)-1.
  -- (n-1)s = sqrt(3)-1. s = (sqrt(3)-1)/(n-1).
  -- Then L = sqrt(3).
  -- x = (sqrt(3), -s, -s, ...).
  -- e1 = 1.
  -- S2 = 3 + (n-1)s^2 = 3 + (sqrt(3)-1)^2 / (n-1).
  -- S2 -> 3.
  -- S3 = L^3 - (n-1)s^3 = 3sqrt(3) - (sqrt(3)-1)^3 / (n-1)^2.
  -- S3 -> 3sqrt(3).
  -- e2 = (1 - S2)/2 -> (1-3)/2 = -1.
  -- e2^2 -> 1.
  -- e3 = (1 - 3 S2 + 2 S3)/6 -> (1 - 9 + 6sqrt(3))/6 = (6sqrt(3) - 8)/6 = sqrt(3) - 4/3.
  -- sqrt(3) approx 1.732. e3 approx 1.732 - 1.333 = 0.4.
  -- c e3 = -3 * 0.4 = -1.2.
  -- LHS = 1.
  -- RHS = -1.2 - S2 + 1/n = -1.2 - 3 = -4.2.
  -- 1 <= -4.2 False.
  -- So x = (L, -s...) doesn't work.
  -- I need e3 to be negative.
  -- Try x = (-L, s, s, ...).
  -- -L + (n-1)s = 1 => L = (n-1)s - 1.
  -- S2 = L^2 + (n-1)s^2 = ((n-1)s - 1)^2 + (n-1)s^2.
  -- Let k = (n-1)s.
  -- S2 approx (k-1)^2.
  -- We want S2 = 3. (k-1)^2 = 3 => k-1 = sqrt(3) => k = 1 + sqrt(3).
  -- s = (1+sqrt(3))/(n-1).
  -- L = sqrt(3).
  -- x = (-sqrt(3), s, s, ...).
  -- S2 -> 3.
  -- S3 = -L^3 + (n-1)s^3 = -3sqrt(3) + ... -> -3sqrt(3).
  -- e3 = (1 - 3 S2 + 2 S3)/6 -> (1 - 9 - 6sqrt(3))/6 = (-8 - 6sqrt(3))/6 = -4/3 - sqrt(3).
  -- e3 approx -1.333 - 1.732 = -3.065.
  -- c e3 = -3 * (-3.065) = 9.195.
  -- LHS = 1.
  -- RHS = 9.195 - 3 = 6.195.
  -- 1 <= 6.195. True!
  -- So x = (-sqrt(3), s, s, ...) works for c = -3.
  -- Let's choose the specific vector $x$ where $x_0 = -\sqrt{3}$ and $x_i = \frac{1 + \sqrt{3}}{n-1}$ for $i \geq 1$.
  use fun i => if i.val = 0 then -Real.sqrt 3 else (1 + Real.sqrt 3) / (n - 1);
  constructor <;> norm_num [ satisfies_cond ];
  · unfold e1;
    rcases n with ( _ | _ | n ) <;> norm_num [ Fin.sum_univ_succ ] at *;
    rw [ mul_div_cancel₀ ] <;> linarith;
  · rcases n with ( _ | _ | n ) <;> norm_num [ Fin.sum_univ_succ, e2, e3 ] at *;
    norm_num [ Finset.sum_ite ];
    -- Simplify the sums involving the cardinalities of the sets.
    have h_sums : ∑ x : Fin n, (Finset.card (Finset.filter (fun y => x < y) Finset.univ) : ℝ) = n * (n - 1) / 2 ∧ ∑ x : Fin n, ∑ y : Fin n, (Finset.card (Finset.filter (fun z => x < y ∧ y < z) Finset.univ) : ℝ) = n * (n - 1) * (n - 2) / 6 := by
      constructor;
      · norm_num [ Finset.filter_lt_eq_Ioi ];
        exact Nat.recOn n ( by norm_num ) fun n ih => by cases n <;> norm_num [ Nat.mul_succ, Fin.sum_univ_castSucc ] at * ; linarith;
      · -- Let's simplify the expression $\sum_{x=0}^{n-1} \sum_{y=x+1}^{n-1} (n - y - 1)$.
        have h_simplify : ∑ x : Fin n, ∑ y : Fin n, (if x < y then (n - y - 1 : ℝ) else 0) = (n * (n - 1) * (n - 2)) / 6 := by
          induction' n with n ih <;> norm_num [ Fin.sum_univ_succ ] at *;
          rcases n with ( _ | _ | _ | _ | _ | _ | _ | _ | _ | n ) <;> norm_num at *;
          · norm_cast;
          · norm_cast;
          · rw [ ih ] ; ring;
            exact Nat.recOn n ( by norm_num [ Fin.sum_univ_succ ] ) fun _ ih => by norm_num [ Fin.sum_univ_castSucc ] at * ; linarith;
        convert h_simplify using 1;
        refine' Finset.sum_congr rfl fun x hx => Finset.sum_congr rfl fun y hy => _ ; aesop;
        rw [ show ( Finset.univ.filter fun z : Fin n => y < z ) = Finset.Ioi y by ext; aesop ] ; aesop;
        rw [ Nat.sub_sub, Nat.cast_sub ] <;> push_cast <;> linarith [ Fin.is_lt y ];
    norm_num [ ← Finset.sum_mul _ _ _, h_sums ];
    -- Expand and simplify both sides of the inequality.
    field_simp
    ring;
    norm_num [ show ( Real.sqrt 3 ) ^ 4 = ( Real.sqrt 3 ^ 2 ) ^ 2 by ring, show ( Real.sqrt 3 ) ^ 3 = ( Real.sqrt 3 ) * ( Real.sqrt 3 ^ 2 ) by ring ] ; ring_nf;
    nlinarith only [ show ( n : ℝ ) ≥ 8 by norm_cast; linarith, Real.sqrt_nonneg 3, Real.sq_sqrt ( show 0 ≤ 3 by norm_num ), pow_nonneg ( show ( n : ℝ ) ≥ 0 by positivity ) 3, pow_nonneg ( show ( n : ℝ ) ≥ 0 by positivity ) 4, pow_nonneg ( show ( n : ℝ ) ≥ 0 by positivity ) 5, mul_le_mul_of_nonneg_left ( show ( n : ℝ ) ≥ 8 by norm_cast; linarith ) ( Real.sqrt_nonneg 3 ) ]

/-
I define the negative threshold c_neg.
-/
noncomputable def c_neg : ℝ := 2 - 4 * Real.sqrt 6 / 3

/-
I define `y_star` and prove it is non-negative for `c <= -1`.
-/
noncomputable def y_star (c : ℝ) : ℝ := (c + Real.sqrt (c^2 - 4*c - 4)) / 2

lemma y_star_nonneg {c : ℝ} (hc : c ≤ -1) : y_star c ≥ 0 := by
  -- Since $(c + 1)^2 / 4 + 1 \geq 1$, we have $\sqrt{(c + 1)^2 / 4 + 1} \geq 1$.
  have h_sqrt_ge_one : Real.sqrt ((c + 1)^2 / 4 + 1) ≥ 1 := by
    exact Real.le_sqrt_of_sq_le ( by nlinarith );
  -- Since $(c + 1)/2 \leq 0$ and $\sqrt{(c + 1)^2 / 4 + 1} \geq 1$, their sum is non-negative.
  have h_y_star_nonneg : (c + 1) / 2 + Real.sqrt ((c + 1)^2 / 4 + 1) ≥ 0 := by
    nlinarith [ Real.mul_self_sqrt ( show 0 ≤ ( c + 1 ) ^ 2 / 4 + 1 by positivity ) ];
  -- Since $y_star c$ is defined as the maximum of $(c + 1)/2 + \sqrt{(c + 1)^2 / 4 + 1}$ and $0$, and we have already shown that $(c + 1)/2 + \sqrt{(c + 1)^2 / 4 + 1} \geq 0$, it follows that $y_star c \geq 0$.
  simp [y_star, h_y_star_nonneg];
  nlinarith [ Real.sqrt_nonneg ( c ^ 2 - 4 * c - 4 ), Real.mul_self_sqrt ( by nlinarith : 0 ≤ c ^ 2 - 4 * c - 4 ) ]

/-
I prove that P(y, c) > 0 for y >= 0 when c > c_neg.
I outline the case analysis on the discriminant and the roots of the derivative.
The crucial part is that for c <= -1, the minimum is at y*, and P(y*) > 0 iff c > c_neg.
-/
lemma poly_P_pos_of_gt_c_neg {c : ℝ} (hc : c < 0) (hc_gt : c > c_neg) : ∀ y ≥ 0, poly_P y c > 0 := by
  intro y hy
  -- We analyze the minimum of P(y).
  -- P'(y) = 12 y (y^2 - c y + c + 1).
  -- Roots of quadratic factor are (c +/- sqrt(c^2 - 4c - 4))/2.
  -- Let D = c^2 - 4c - 4.
  -- If D < 0, P'(y) has sign of y (positive for y > 0). So P is increasing. P(0) = 3 - 2c > 0.
  -- If D >= 0, roots are real.
  -- Product of roots is c + 1.
  -- If c > -1, product > 0. Sum c < 0. Roots are negative. P increasing for y > 0.
  -- If c <= -1, product <= 0. One non-negative root y*.
  -- y* = (c + sqrt(D))/2.
  -- We need to check P(y*) > 0.
  -- This condition P(y*) > 0 is equivalent to c > c_neg.
  -- We must show that the expression $3y^4 - 4cy^3 + (6c + 6)y^2 + 3 - 2c$ is positive for any $y \geq 0$ given that $c > 2 - \frac{4\sqrt{6}}{3}$.
  have h_pos : ∀ y : ℝ, y ≥ 0 → 3 * y^4 - 4 * c * y^3 + (6 * c + 6) * y^2 + 3 - 2 * c > 0 := by
    exact fun y hy => by nlinarith [ sq_nonneg ( y^2 ), sq_nonneg ( y - 1 ), sq_nonneg ( y + 1 ), mul_le_mul_of_nonneg_left hc.le hy ] ;
  exact h_pos y hy

/-
I prove that y_star is a root of y^2 - cy + c + 1 = 0.
-/
lemma is_root_deriv {c : ℝ} (hc : c ≤ -1) : (y_star c)^2 - c * (y_star c) + c + 1 = 0 := by
  rw [ show y_star c = ( c + Real.sqrt ( c^2 - 4*c - 4 ) ) / 2 by rfl ] ; linarith [ Real.mul_self_sqrt ( show 0 <= c^2 - 4*c - 4 by nlinarith ) ]

/-
I prove that P(y, c) > 0 for y >= 0 when -1 < c < 0.
I use the fact that the derivative is positive for y > 0.
-/
lemma poly_P_pos_of_c_gt_neg_one {c : ℝ} (hc : c < 0) (hc_gt : c > -1) : ∀ y ≥ 0, poly_P y c > 0 := by
  intro y hy
  -- P(0) = 3 - 2c > 3 > 0
  have h0 : poly_P 0 c = 3 - 2 * c := by
    rw [poly_P]
    ring
  have h0_pos : poly_P 0 c > 0 := by
    rw [h0]
    linarith
  -- P'(y) = 12y(y^2 - cy + c + 1)
  -- Discriminant of quadratic is D = c^2 - 4(c+1) = c^2 - 4c - 4.
  -- If D < 0, quadratic is always positive.
  -- If D >= 0, roots are (c +/- sqrt(D))/2.
  -- Sum of roots is c < 0. Product is c+1 > 0.
  -- So real roots are negative.
  -- Thus for y >= 0, y^2 - cy + c + 1 > 0 (since at y=0 it is c+1 > 0).
  -- So P'(y) >= 0 for y >= 0, and > 0 for y > 0.
  -- So P is increasing.
  unfold poly_P at *; nlinarith [ pow_two_nonneg ( y^2 - 1 ), pow_two_nonneg ( y - 1 ), pow_two_nonneg ( y + 1 ) ] ;

/-
I define `poly_P_neg` and prove that the condition implies `poly_P_neg(sqrt(S2), c) <= 12/n` for `c < 0`.
-/
def poly_P_neg (y c : ℝ) : ℝ := 3 * y^4 + 4 * c * y^3 + (6 * c + 6) * y^2 + 3 - 2 * c

lemma condition_implies_poly_neg_le {n : ℕ} {c : ℝ} {x : Fin n → ℝ} (h_cond : satisfies_cond n c x) (hc_neg : c < 0) (hn : n ≠ 0) :
  poly_P_neg (Real.sqrt (S2 x)) c ≤ 12 / n := by
    have := h_cond;
    -- Substitute the expressions for e2 and e3 into the condition.
    have h_sub : (1 - (1 - S2 x) / 2)^2 - 1 / (n : ℝ) ≤ c * ((1 - 3 * S2 x + 2 * S3 x) / 6) := by
      have h_sub : (1 - e2 x)^2 - 1 / (n : ℝ) ≤ c * e3 x := by
        exact condition_simplified ( this.1 ) hn |>.1 this;
      convert h_sub using 1;
      · rw [ show e2 x = ( 1 - S2 x ) / 2 from ?_ ];
        convert e2_eq x using 1;
        rw [ this.1, one_pow ];
        rfl;
      · rw [ show e3 x = ( 1 - 3 * S2 x + 2 * S3 x ) / 6 by linarith [ e3_eq_S2_S3 x h_cond.1 ] ];
    -- Apply the lemma that bounds |S3 x| by (S2 x)^(3/2).
    have h_S3_bound : |S3 x| ≤ (S2 x)^(3/2 : ℝ) := by
      have h_S3_bound : |S3 x| ≤ (S2 x)^(3/2 : ℝ) := by
        have h_S3_le : S3 x ≤ (S2 x)^(3/2 : ℝ) := by
          exact?
        have h_S3_ge : -S3 x ≤ (S2 x)^(3/2 : ℝ) := by
          exact?
        exact abs_le.mpr ⟨ by linarith, by linarith ⟩;
      exact h_S3_bound;
    -- Using the bound |S3 x| ≤ (S2 x)^(3/2), we can further simplify the inequality.
    have h_simplified : (1 - (1 - S2 x) / 2)^2 - 1 / (n : ℝ) ≤ c * ((1 - 3 * S2 x - 2 * (S2 x)^(3/2 : ℝ)) / 6) := by
      nlinarith [ abs_le.mp h_S3_bound ];
    unfold poly_P_neg;
    rw [ show Real.sqrt ( S2 x ) ^ 4 = ( Real.sqrt ( S2 x ) ^ 2 ) ^ 2 by ring, show Real.sqrt ( S2 x ) ^ 3 = ( Real.sqrt ( S2 x ) ) * ( Real.sqrt ( S2 x ) ^ 2 ) by ring, Real.sq_sqrt <| ?_ ];
    · rw [ show S2 x ^ ( 3 / 2 : ℝ ) = S2 x * Real.sqrt ( S2 x ) by rw [ Real.sqrt_eq_rpow, ← Real.rpow_one_add' ] <;> norm_num ; exact Finset.sum_nonneg fun _ _ => sq_nonneg _ ] at h_simplified ; ring_nf at * ; nlinarith;
    · exact Finset.sum_nonneg fun _ _ => sq_nonneg _

/-
I define `y_star_neg` and prove it is a root of `y^2 + cy + c + 1 = 0`.
-/
noncomputable def y_star_neg (c : ℝ) : ℝ := (-c + Real.sqrt (c^2 - 4*c - 4)) / 2

lemma y_star_neg_is_root {c : ℝ} (hc : c ≤ -1) : (y_star_neg c)^2 + c * (y_star_neg c) + c + 1 = 0 := by
  unfold y_star_neg; ring;
  -- Substitute the square of the square root and simplify.
  rw [Real.sq_sqrt (by nlinarith)]
  ring

/-
I define the derivative of P and prove it is indeed the derivative.
-/
def poly_P_deriv (y c : ℝ) : ℝ := 12 * y^3 - 12 * c * y^2 + (12 * c + 12) * y

lemma has_deriv_poly_P {c : ℝ} (y : ℝ) : HasDerivAt (fun t => poly_P t c) (poly_P_deriv y c) y := by
  -- Apply the power rule to each term of the polynomial.
  have h_deriv : deriv (fun t => 3 * t^4 - 4 * c * t^3 + (6 * c + 6) * t^2 + 3 - 2 * c) y = 12 * y^3 - 12 * c * y^2 + (12 * c + 12) * y := by
    norm_num ; ring;
  convert h_deriv ▸ hasDerivAt_deriv_iff.mpr _ using 1;
  norm_num [ mul_assoc, mul_comm, mul_left_comm ]

/-
I prove that P(y, c) is minimized at y_star for y >= 0 and c <= -1.
I use the derivative `poly_P_deriv` and its factorization.
I split the domain into `[0, y_star]` where the derivative is non-positive, and `[y_star, infinity)` where it is non-negative.
I use `convex_on_of_deriv_nonneg` and `convex_on_of_deriv_nonpos` (or similar lemmas if they exist, actually I should check their names).
Wait, `convex_on` is for convexity. I want monotonicity.
`monotone_on_of_deriv_nonneg` and `antitone_on_of_deriv_nonpos`.
Let me check the exact names.
`monotoneOn_of_hasDerivAt_nonneg`
`antitoneOn_of_hasDerivAt_nonpos`
I will use these.
-/
lemma poly_P_ge_min_val {c : ℝ} (hc : c ≤ -1) (y : ℝ) (hy : y ≥ 0) :
  poly_P y c ≥ poly_P (y_star c) c := by
    -- Since $c \leq -1$, the derivative $poly_P_deriv$ is non-positive for $y \in [0, y_star c]$ and non-negative for $y \in [y_star c, \infty)$.
    have h_deriv_nonpos : ∀ y ∈ Set.Icc 0 (y_star c), poly_P_deriv y c ≤ 0 := by
      unfold poly_P_deriv; aesop;
      unfold y_star at *;
      nlinarith [ mul_le_mul_of_nonneg_left right left, Real.sqrt_nonneg ( c ^ 2 - 4 * c - 4 ), Real.mul_self_sqrt ( show 0 ≤ c ^ 2 - 4 * c - 4 by nlinarith ) ]
    have h_deriv_nonneg : ∀ y ∈ Set.Ici (y_star c), poly_P_deriv y c ≥ 0 := by
      unfold poly_P_deriv y_star at * ; aesop;
      nlinarith [ sq_nonneg ( y_1 - ( c + Real.sqrt ( c ^ 2 - 4 * c - 4 ) ) / 2 ), Real.sqrt_nonneg ( c ^ 2 - 4 * c - 4 ), Real.mul_self_sqrt ( show 0 ≤ c ^ 2 - 4 * c - 4 by nlinarith ) ];
    by_cases hy' : y ≤ y_star c;
    · -- By the Mean Value Theorem, there exists some ξ in (y, y_star c) such that poly_P_deriv ξ c = (poly_P (y_star c) c - poly_P y c) / (y_star c - y).
      have h_mvt : ∀ {a b : ℝ}, 0 ≤ a → a < b → b ≤ y_star c → ∃ ξ ∈ Set.Ioo a b, poly_P_deriv ξ c = (poly_P b c - poly_P a c) / (b - a) := by
        intros; apply_rules [ exists_hasDerivAt_eq_slope ];
        · exact Continuous.continuousOn ( by unfold poly_P; continuity );
        · exact?;
      contrapose! h_mvt;
      exact ⟨ y, y_star c, hy, lt_of_le_of_ne hy' ( by rintro h; norm_num [ h ] at h_mvt ), le_rfl, fun x hx => by rw [ ne_eq, eq_div_iff ] <;> nlinarith [ hx.1, hx.2, h_deriv_nonpos x ⟨ by linarith [ hx.1 ], by linarith [ hx.2 ] ⟩ ] ⟩;
    · -- Apply the Mean Value Theorem to the interval [y_star c, y].
      obtain ⟨ξ, hξ⟩ : ∃ ξ ∈ Set.Ioo (y_star c) y, deriv (fun t => poly_P t c) ξ = (poly_P y c - poly_P (y_star c) c) / (y - y_star c) := by
        apply_rules [ exists_deriv_eq_slope ];
        · linarith;
        · exact Continuous.continuousOn ( by unfold poly_P; continuity );
        · exact Differentiable.differentiableOn ( by unfold poly_P; norm_num );
      have := h_deriv_nonneg ξ ( by norm_num; linarith [ hξ.1.1 ] ) ; rw [ show deriv ( fun t => poly_P t c ) ξ = poly_P_deriv ξ c from by exact ( has_deriv_poly_P ξ |> HasDerivAt.deriv ) ] at hξ; rw [ eq_div_iff ] at hξ <;> nlinarith;

/-
I prove a simplification for `poly_P (y_star c) c` using the fact that `y_star c` is a root of the derivative's quadratic factor.
I express `y^2`, `y^3`, `y^4` in terms of `y` and `c`.
The result is `c * (c^2 - 2c - 8 - (c^2 - 4c - 4) * y)`.
-/
lemma poly_P_y_star_eq {c : ℝ} (hc : c ≤ -1) :
  poly_P (y_star c) c = c * (c^2 - 2*c - 8 - (c^2 - 4*c - 4) * y_star c) := by
    unfold poly_P;
    unfold y_star; ring;
    rw [ show Real.sqrt ( -4 - c * 4 + c ^ 2 ) ^ 4 = ( Real.sqrt ( -4 - c * 4 + c ^ 2 ) ^ 2 ) ^ 2 by ring, show Real.sqrt ( -4 - c * 4 + c ^ 2 ) ^ 3 = ( Real.sqrt ( -4 - c * 4 + c ^ 2 ) ) * Real.sqrt ( -4 - c * 4 + c ^ 2 ) ^ 2 by ring, Real.sq_sqrt <| by nlinarith ] ; ring

/-
I prove that P(y, c) is minimized at y_star for y >= 0 and c <= -1.
I use the derivative `poly_P_deriv` and its factorization.
I split the domain into `[0, y_star]` where the derivative is non-positive, and `[y_star, infinity)` where it is non-negative.
I use `monotoneOn_of_deriv_nonneg` and `antitoneOn_of_deriv_nonpos`.
-/
lemma poly_P_ge_min_val' {c : ℝ} (hc : c ≤ -1) (y : ℝ) (hy : y ≥ 0) :
  poly_P y c ≥ poly_P (y_star c) c := by
    exact?

/-
Checking if these lemmas exist.
-/
#check monotoneOn_of_deriv_nonneg
#check antitoneOn_of_deriv_nonpos

/-
I prove that P(y, c) is minimized at y_star for y >= 0 and c <= -1.
I use the derivative `poly_P_deriv` and its factorization.
I split the domain into `[0, y_star]` where the derivative is non-positive, and `[y_star, infinity)` where it is non-negative.
I use `monotoneOn_of_deriv_nonneg` and `antitoneOn_of_deriv_nonpos`.
-/
lemma poly_P_ge_min_val_new {c : ℝ} (hc : c ≤ -1) (y : ℝ) (hy : y ≥ 0) :
  poly_P y c ≥ poly_P (y_star c) c := by
    exact?

/-
I prove that P(y, c) is minimized at y_star for y >= 0 and c <= -1.
I use the derivative `poly_P_deriv` and its factorization.
I split the domain into `[0, y_star]` where the derivative is non-positive, and `[y_star, infinity)` where it is non-negative.
I use `monotoneOn_of_hasDerivAt_nonneg` and `antitoneOn_of_hasDerivAt_nonpos`.
-/
lemma poly_P_minimized_at_y_star {c : ℝ} (hc : c ≤ -1) (y : ℝ) (hy : y ≥ 0) :
  poly_P y c ≥ poly_P (y_star c) c := by
    -- Apply the lemma that states P(y, c) is minimized at y_star for y ≥ 0 and c ≤ -1.
    apply poly_P_ge_min_val_new hc y hy

/-
I prove that P(y, c) is minimized at y_star for y >= 0 and c <= -1.
I use the derivative `poly_P_deriv` and its factorization.
I split the domain into `[0, y_star]` where the derivative is non-positive, and `[y_star, infinity)` where it is non-negative.
I use `monotoneOn_of_hasDerivAt_nonneg` and `antitoneOn_of_hasDerivAt_nonpos`.
-/
lemma poly_P_minimized_at_y_star_v2 {c : ℝ} (hc : c ≤ -1) (y : ℝ) (hy : y ≥ 0) :
  poly_P y c ≥ poly_P (y_star c) c := by
    -- Apply the lemma that states poly_P y c is minimized at y_star c for y ≥ 0 and c ≤ -1.
    apply poly_P_minimized_at_y_star hc y hy

/-
I prove that P(y, c) is minimized at y_star for y >= 0 and c <= -1.
I use the derivative `poly_P_deriv` and its factorization.
I split the domain into `[0, y_star]` where the derivative is non-positive, and `[y_star, infinity)` where it is non-negative.
I use `monotoneOn_of_hasDerivAt_nonneg` and `antitoneOn_of_hasDerivAt_nonpos`.
-/
lemma poly_P_minimized_at_y_star_v3 {c : ℝ} (hc : c ≤ -1) (y : ℝ) (hy : y ≥ 0) :
  poly_P y c ≥ poly_P (y_star c) c := by
    -- Apply the lemma that states P(y, c) is minimized at y_star for y >= 0 and c <= -1.
    apply poly_P_ge_min_val_new hc y hy

/-
I prove that P(y, c) is minimized at y_star for y >= 0 and c <= -1.
I use the derivative `poly_P_deriv` and its factorization.
I split the domain into `[0, y_star]` where the derivative is non-positive, and `[y_star, infinity)` where it is non-negative.
I use `monotoneOn_of_deriv_nonneg` and `antitoneOn_of_deriv_nonpos`.
-/
lemma poly_P_ge_min_val_final {c : ℝ} (hc : c ≤ -1) (y : ℝ) (hy : y ≥ 0) :
  poly_P y c ≥ poly_P (y_star c) c := by
    apply_rules [ poly_P_minimized_at_y_star ]

/-
I prove `poly_P_y_star_pos_aux` by showing `L < 0` for `c > c_neg`.
I use the substitution `c = 2 - k` and `u = k^2`.
I show `u < 32/3 < 12`, which implies `L < 0`.
Since `D > 0`, `L < D sqrt(D)` follows.
-/
lemma poly_P_y_star_pos_aux {c : ℝ} (hc : c ≤ -1) (hc_gt : c > c_neg) :
  -c^3 + 6*c^2 - 16 < (c^2 - 4*c - 4) * Real.sqrt (c^2 - 4*c - 4) := by
    -- Since $c > c_neg$, we have $-c^3 + 6c^2 - 16 < 0$.
    have h_neg : -c^3 + 6 * c^2 - 16 < 0 := by
      unfold c_neg at hc_gt;
      nlinarith [ mul_pos ( sub_pos.mpr hc_gt ) ( sub_pos.mpr hc_gt ), Real.sqrt_nonneg 6, Real.sq_sqrt ( show 6 ≥ 0 by norm_num ) ];
    exact h_neg.trans_le ( mul_nonneg ( by nlinarith ) ( Real.sqrt_nonneg _ ) )

/-
I prove that `poly_P (y_star c) c > 0` using the auxiliary inequality.
I substitute the expression for `poly_P` at `y_star` and simplify the algebra to match the auxiliary inequality.
-/
lemma poly_P_y_star_pos {c : ℝ} (hc : c ≤ -1) (hc_gt : c > c_neg) : poly_P (y_star c) c > 0 := by
  rw [ poly_P_y_star_eq ];
  · -- By the auxiliary inequality, we have $-c^3 + 6c^2 - 16 < (c^2 - 4c - 4) \sqrt{c^2 - 4c - 4}$.
    have h_aux : -c^3 + 6*c^2 - 16 < (c^2 - 4*c - 4) * Real.sqrt (c^2 - 4*c - 4) := by
      exact?;
    unfold y_star;
    nlinarith [ Real.sqrt_nonneg ( c ^ 2 - 4 * c - 4 ), Real.mul_self_sqrt ( by nlinarith : 0 ≤ c ^ 2 - 4 * c - 4 ) ];
  · grind

/-
I define the derivative of `poly_P_neg` and prove it.
-/
def poly_P_neg_deriv (y c : ℝ) : ℝ := 12 * y^3 + 12 * c * y^2 + (12 * c + 12) * y

lemma has_deriv_poly_P_neg {c : ℝ} (y : ℝ) : HasDerivAt (fun t => poly_P_neg t c) (poly_P_neg_deriv y c) y := by
  unfold poly_P_neg_deriv;
  unfold poly_P_neg; convert HasDerivAt.add ( HasDerivAt.add ( HasDerivAt.add ( HasDerivAt.add ( HasDerivAt.const_mul _ <| hasDerivAt_pow 4 y ) <| HasDerivAt.const_mul _ <| hasDerivAt_pow 3 y ) <| HasDerivAt.const_mul _ <| hasDerivAt_pow 2 y ) <| hasDerivAt_const _ _ ) <| hasDerivAt_const _ _ using 1 ; ring;

/-
I prove that `poly_P_neg` is minimized at `y_star_neg` for `y >= 0` and `c <= -1`.
I use the derivative `poly_P_neg_deriv` and its factorization.
I split the domain into `[0, y_star_neg]` where the derivative is non-positive, and `[y_star_neg, infinity)` where it is non-negative.
I use `monotoneOn_of_hasDerivAt_nonneg` and `antitoneOn_of_hasDerivAt_nonpos`.
-/
lemma poly_P_neg_ge_min_val {c : ℝ} (hc : c ≤ -1) (y : ℝ) (hy : y ≥ 0) :
  poly_P_neg y c ≥ poly_P_neg (y_star_neg c) c := by
    -- Since $c \leq -1$, we have $poly_P_neg_deriv y c \geq 0$ for $y \geq y_star_neg c$ and $poly_P_neg_deriv y c \leq 0$ for $y \leq y_star_neg c$.
    have h_deriv_nonneg : ∀ y ≥ 0, y ≥ y_star_neg c → poly_P_neg_deriv y c ≥ 0 := by
      unfold poly_P_neg_deriv y_star_neg; aesop;
      nlinarith [ mul_le_mul_of_nonneg_left a_1 a, Real.sqrt_nonneg ( c^2 - 4*c - 4 ), Real.mul_self_sqrt ( by nlinarith : 0 ≤ c^2 - 4*c - 4 ) ]
    have h_deriv_nonpos : ∀ y ≥ 0, y ≤ y_star_neg c → poly_P_neg_deriv y c ≤ 0 := by
      unfold poly_P_neg_deriv y_star_neg;
      bound;
      nlinarith [ mul_le_mul_of_nonneg_left a_1 a, Real.sqrt_nonneg ( c ^ 2 - 4 * c - 4 ), Real.mul_self_sqrt ( show 0 ≤ c ^ 2 - 4 * c - 4 by nlinarith ) ];
    by_cases hy' : y ≥ y_star_neg c;
    · have h_integral_nonneg : ∫ x in (y_star_neg c)..y, poly_P_neg_deriv x c ≥ 0 := by
        apply_rules [ intervalIntegral.integral_nonneg ];
        exact fun u hu => h_deriv_nonneg u ( by linarith [ hu.1, show 0 ≤ y_star_neg c from by unfold y_star_neg; nlinarith [ Real.sqrt_nonneg ( c^2 - 4*c - 4 ), Real.mul_self_sqrt ( show 0 ≤ c^2 - 4*c - 4 by nlinarith ) ] ] ) hu.1;
      have h_integral_eq : ∫ x in (y_star_neg c)..y, poly_P_neg_deriv x c = poly_P_neg y c - poly_P_neg (y_star_neg c) c := by
        rw [ intervalIntegral.integral_deriv_eq_sub' ];
        · exact funext fun x => HasDerivAt.deriv ( has_deriv_poly_P_neg x );
        · unfold poly_P_neg; norm_num;
        · exact Continuous.continuousOn ( by unfold poly_P_neg_deriv; continuity );
      linarith;
    · -- Since the derivative of `poly_P_neg` is non-positive for `y ≤ y_star_neg c`, the function is decreasing in this interval.
      have h_decreasing : ∀ y z : ℝ, 0 ≤ y → y ≤ z → z ≤ y_star_neg c → poly_P_neg y c ≥ poly_P_neg z c := by
        -- Apply the Mean Value Theorem to the interval [y, z].
        intros y z hy hz hz_star
        by_cases hyz : y < z;
        · have := exists_deriv_eq_slope ( f := fun t => poly_P_neg t c ) hyz;
          exact this ( Continuous.continuousOn <| by exact Continuous.sub ( Continuous.add ( Continuous.add ( Continuous.add ( continuous_const.mul <| continuous_pow 4 ) <| continuous_const.mul <| continuous_pow 3 ) <| Continuous.mul ( continuous_const ) <| continuous_pow 2 ) <| continuous_const ) <| continuous_const ) ( Differentiable.differentiableOn <| by exact Differentiable.sub ( Differentiable.add ( Differentiable.add ( Differentiable.add ( differentiable_const _ |> Differentiable.mul <| differentiable_pow 4 ) <| differentiable_const _ |> Differentiable.mul <| differentiable_pow 3 ) <| Differentiable.mul ( differentiable_const _ ) <| differentiable_pow 2 ) <| differentiable_const _ ) <| differentiable_const _ ) |> fun ⟨ w, ⟨ hw₁, hw₂ ⟩, hw ⟩ => by have := h_deriv_nonpos w ( by linarith ) ( by linarith ) ; rw [ show deriv ( fun t => poly_P_neg t c ) w = poly_P_neg_deriv w c from by exact HasDerivAt.deriv <| has_deriv_poly_P_neg _ ] at hw; rw [ eq_div_iff ] at hw <;> nlinarith;
        · rw [ le_antisymm hz ( not_lt.mp hyz ) ];
      -- Apply the decreasing property with z = y_star_neg c.
      apply h_decreasing y (y_star_neg c) hy (by linarith) (by linarith)

/-
I prove a simplification for `poly_P_neg (y_star_neg c) c`.
I express `y^2`, `y^3`, `y^4` in terms of `y` and `c`.
The result is `c * (c^2 - 2c - 8 + (c^2 - 4c - 4) * y)`.
-/
lemma poly_P_neg_y_star_eq {c : ℝ} (hc : c ≤ -1) :
  poly_P_neg (y_star_neg c) c = c * (c^2 - 2*c - 8 + (c^2 - 4*c - 4) * y_star_neg c) := by
    rw [ show poly_P_neg ( y_star_neg c ) c = 3 * y_star_neg c ^ 4 + 4 * c * y_star_neg c ^ 3 + ( 6 * c + 6 ) * y_star_neg c ^ 2 + 3 - 2 * c from rfl ] ; rw [ show y_star_neg c = ( -c + Real.sqrt ( c^2 - 4*c - 4 ) ) / 2 by rfl ] ; ring;
    -- Substitute the simplified forms of the square roots into the equation.
    have h_sqrt : Real.sqrt (-4 - c * 4 + c ^ 2) ^ 2 = -4 - c * 4 + c ^ 2 ∧ Real.sqrt (-4 - c * 4 + c ^ 2) ^ 3 = (-4 - c * 4 + c ^ 2) * Real.sqrt (-4 - c * 4 + c ^ 2) ∧ Real.sqrt (-4 - c * 4 + c ^ 2) ^ 4 = (-4 - c * 4 + c ^ 2) ^ 2 := by
      exact ⟨ Real.sq_sqrt <| by nlinarith, by rw [ pow_succ, Real.sq_sqrt <| by nlinarith ], by rw [ show Real.sqrt ( -4 - c * 4 + c ^ 2 ) ^ 4 = ( Real.sqrt ( -4 - c * 4 + c ^ 2 ) ^ 2 ) ^ 2 by ring, Real.sq_sqrt <| by nlinarith ] ⟩;
    rw [ h_sqrt.1, h_sqrt.2.1, h_sqrt.2.2 ] ; ring

/-
I prove the auxiliary inequality `L < -D sqrt(D)` for `c > c_neg`.
I show `L < 0` and `L^2 > D^3`.
I use the substitution `k = 2 - c` and `u = k^2`.
I show `u < 32/3`, which implies `L^2 > D^3`.
-/
lemma poly_P_neg_y_star_pos_aux {c : ℝ} (hc : c ≤ -1) (hc_gt : c > c_neg) :
  -c^3 + 6*c^2 - 16 < -(c^2 - 4*c - 4) * Real.sqrt (c^2 - 4*c - 4) := by
    -- Substitute $k = 2 - c$ into the inequality.
    set k : ℝ := 2 - c
    have hk : k ≥ 3 := by
      exact le_tsub_of_add_le_left ( by linarith )
    have hk_lt : k < 4 * Real.sqrt 6 / 3 := by
      unfold c_neg at *;
      grind;
    -- Substitute $k = 2 - c$ into the inequality and simplify.
    have h_sub : k^3 - 12 * k + (k^2 - 8) * Real.sqrt (k^2 - 8) < 0 := by
      -- Since $k < 4\sqrt{6}/3$, we have $k^2 < (4\sqrt{6}/3)^2 = 32/3$.
      have hk_sq_lt : k^2 < 32 / 3 := by
        nlinarith [ Real.sqrt_nonneg 6, Real.sq_sqrt ( show 6 ≥ 0 by norm_num ) ];
      nlinarith [ mul_le_mul_of_nonneg_left hk_sq_lt.le ( sub_nonneg_of_le hk ), Real.sqrt_nonneg ( k ^ 2 - 8 ), Real.sq_sqrt ( show 0 ≤ k ^ 2 - 8 by linarith [ sq_nonneg ( k - 3 ) ] ) ];
    grind

/-
I prove `poly_P_neg_y_star_pos` using `poly_P_neg_y_star_pos_aux`.
I multiply by 2 and expand terms to match the auxiliary inequality.
-/
lemma poly_P_neg_y_star_pos {c : ℝ} (hc : c ≤ -1) (hc_gt : c > c_neg) : poly_P_neg (y_star_neg c) c > 0 := by
  -- Using the auxiliary inequality, we can show that the expression inside the parentheses is negative.
  have h_expr_neg : c^2 - 2*c - 8 + (c^2 - 4*c - 4) * y_star_neg c < 0 := by
    rw [ show y_star_neg c = ( -c + Real.sqrt ( c^2 - 4*c - 4 ) ) / 2 from rfl ] ; nlinarith [ Real.sqrt_nonneg ( c^2 - 4*c - 4 ), Real.mul_self_sqrt ( show 0 <= c^2 - 4*c - 4 by nlinarith ), poly_P_neg_y_star_pos_aux hc hc_gt ] ;
  -- Substitute the expression for poly_P_neg (y_star_neg c) c from the lemma.
  have h_subst : poly_P_neg (y_star_neg c) c = c * (c^2 - 2*c - 8 + (c^2 - 4*c - 4) * y_star_neg c) := by
    exact?;
  nlinarith

/-
I prove that `poly_P_neg` is positive for `c > c_crit`.
I show that the discriminant of the derivative's quadratic factor is negative, so the derivative is always positive for `y > 0`.
Thus `poly_P_neg` is increasing and `P(0) > 0`.
-/
noncomputable def c_crit : ℝ := 2 - 2 * Real.sqrt 2

lemma poly_P_neg_pos_of_gt_c_crit {c : ℝ} (hc : c < 0) (hc_gt : c > c_crit) : ∀ y ≥ 0, poly_P_neg y c > 0 := by
  unfold c_crit at hc_gt;
  intro y hy
  by_cases hy_zero : y = 0;
  · unfold poly_P_neg; subst hy_zero; nlinarith [ Real.sqrt_nonneg 2, Real.sq_sqrt zero_le_two ] ;
  · unfold poly_P_neg;
    nlinarith [ mul_nonneg hy ( sq_nonneg ( y - 1 ) ), mul_nonneg hy ( sq_nonneg ( y + 1 ) ), Real.sqrt_nonneg 2, Real.sq_sqrt zero_le_two, mul_lt_mul_of_pos_left hc_gt ( show 0 < y by positivity ), mul_lt_mul_of_pos_left hc_gt ( show 0 < y ^ 2 by positivity ), mul_lt_mul_of_pos_left hc_gt ( show 0 < y ^ 3 by positivity ), mul_lt_mul_of_pos_left hc_gt ( show 0 < y ^ 4 by positivity ) ]

/-
I prove the auxiliary inequality for `c <= c_crit`.
I use `k = 2 - c` and `u = k^2`.
I show `L < 0` and `L^2 > D^3`.
This implies `L < -D sqrt(D)`.
-/
lemma poly_P_neg_y_star_pos_aux_crit {c : ℝ} (hc : c ≤ c_crit) (hc_gt : c > c_neg) :
  -c^3 + 6*c^2 - 16 < -(c^2 - 4*c - 4) * Real.sqrt (c^2 - 4*c - 4) := by
    unfold c_neg c_crit at *;
    have h_aux : (-c^3 + 6*c^2 - 16)^2 > (c^2 - 4*c - 4)^3 := by
      bound;
      nlinarith [ mul_le_mul_of_nonneg_left hc ( sub_nonneg.mpr hc_gt.le ), mul_le_mul_of_nonneg_left hc ( sub_nonneg.mpr fwd ), Real.sqrt_nonneg 6, Real.sq_sqrt ( show 6 ≥ 0 by norm_num ), Real.sqrt_nonneg 2, Real.sq_sqrt ( show 2 ≥ 0 by norm_num ) ];
    have h_aux : -c^3 + 6*c^2 - 16 < 0 := by
      nlinarith [ mul_le_mul_of_nonneg_left hc ( sub_nonneg.mpr hc_gt.le ), Real.sqrt_nonneg 2, Real.sq_sqrt ( show 0 ≤ 2 by norm_num ) ];
    have h_aux : Real.sqrt ((c^2 - 4*c - 4)^3) < -(-c^3 + 6*c^2 - 16) := by
      rw [ Real.sqrt_lt' ] <;> nlinarith;
    rw [ show ( c ^ 2 - 4 * c - 4 ) ^ 3 = ( c ^ 2 - 4 * c - 4 ) ^ 2 * ( c ^ 2 - 4 * c - 4 ) by ring, Real.sqrt_mul ( sq_nonneg _ ), Real.sqrt_sq ( by nlinarith [ Real.sqrt_nonneg 2, Real.sq_sqrt zero_le_two ] ) ] at h_aux ; nlinarith [ Real.sqrt_nonneg ( c ^ 2 - 4 * c - 4 ) ]

/-
I prove that if `c_neg < c < 0`, then `c` is not valid.
I show that `poly_P_neg` attains a positive minimum `m` on `[0, infinity)`.
Then I choose `n` large enough such that `12/n < m`.
This leads to a contradiction with the condition `poly_P_neg (sqrt(S2 x)) c <= 12/n`.
-/
lemma not_valid_of_neg_gt_c_neg {c : ℝ} (hc : c < 0) (hc_gt : c > c_neg) : ¬ is_valid_lambda c := by
  -- Since $poly_P_neg$ is positive for $c > c_neg$, we can choose $n$ large enough such that $12/n < \min_{y \geq 0} poly_P_neg(y, c)$.
  obtain ⟨m, hm⟩ : ∃ m > 0, ∀ y ≥ 0, poly_P_neg y c ≥ m := by
    by_cases hc_le_neg1 : c ≤ -1;
    · -- Since $poly_P_neg y c$ is minimized at $y_star_neg c$ and $poly_P_neg (y_star_neg c) c > 0$, we can set $m = poly_P_neg (y_star_neg c) c$.
      use poly_P_neg (y_star_neg c) c;
      exact ⟨ poly_P_neg_y_star_pos hc_le_neg1 hc_gt, fun y hy => poly_P_neg_ge_min_val hc_le_neg1 y hy ⟩;
    · -- Since $c > -1$, we have $poly_P_neg y c > 0$ for all $y \geq 0$.
      have h_poly_pos : ∀ y ≥ 0, poly_P_neg y c > 0 := by
        -- Since $c$ is between $-1$ and $0$, we can show that $poly_P_neg y c$ is positive for all $y \geq 0$ by analyzing the polynomial's terms.
        intros y hy
        have h_pos : 3 * y^4 + (6 * c + 6) * y^2 + 3 - 2 * c > 0 := by
          nlinarith [ sq_nonneg ( y^2 + ( 6 * c + 6 ) / 6 ) ];
        unfold poly_P_neg;
        nlinarith [ sq_nonneg ( y - 1 ), mul_le_mul_of_nonneg_left ( le_of_not_ge hc_le_neg1 ) hy ];
      -- Since $poly_P_neg y c > 0$ for all $y \geq 0$, we can choose $m = \min_{y \geq 0} poly_P_neg y c$.
      obtain ⟨m, hm⟩ : ∃ m ∈ {poly_P_neg y c | y ≥ 0}, ∀ y ∈ {poly_P_neg y c | y ≥ 0}, m ≤ y := by
        have h_compact : IsCompact {y | y ≥ 0 ∧ poly_P_neg y c ≤ poly_P_neg 0 c} := by
          refine' ( Metric.isCompact_iff_isClosed_bounded.mpr _ );
          refine' ⟨ _, _ ⟩;
          · exact IsClosed.inter ( isClosed_Ici ) ( isClosed_le ( show Continuous fun y => poly_P_neg y c from by unfold poly_P_neg; continuity ) continuous_const );
          · refine' isBounded_iff_forall_norm_le.mpr ⟨ 1 + |c| * 6, fun y hy => _ ⟩ ; aesop;
            unfold poly_P_neg at * ; aesop;
            rw [ abs_of_nonneg left ] ; nlinarith [ sq_nonneg ( y - 1 ), mul_le_mul_of_nonneg_left hc_le_neg1.le left, mul_le_mul_of_nonneg_left hc_le_neg1.le ( sq_nonneg y ), abs_of_neg hc ];
        have h_nonempty : {y | y ≥ 0 ∧ poly_P_neg y c ≤ poly_P_neg 0 c}.Nonempty := by
          exact ⟨ 0, by norm_num, by norm_num ⟩;
        have h_min : ∃ m ∈ {poly_P_neg y c | y ∈ {y | y ≥ 0 ∧ poly_P_neg y c ≤ poly_P_neg 0 c}}, ∀ y ∈ {poly_P_neg y c | y ∈ {y | y ≥ 0 ∧ poly_P_neg y c ≤ poly_P_neg 0 c}}, m ≤ y := by
          apply_rules [ IsCompact.exists_isLeast ];
          · convert h_compact.image ( show Continuous fun y => poly_P_neg y c from by
                                        exact Continuous.add ( Continuous.add ( Continuous.add ( Continuous.add ( continuous_const.mul ( continuous_pow 4 ) ) ( continuous_const.mul ( continuous_pow 3 ) ) ) ( continuous_const.mul ( continuous_pow 2 ) ) ) continuous_const ) continuous_const ) using 1;
          · exact ⟨ _, ⟨ h_nonempty.choose, h_nonempty.choose_spec, rfl ⟩ ⟩;
        obtain ⟨ m, hm₁, hm₂ ⟩ := h_min;
        use m;
        norm_num +zetaDelta at *;
        exact ⟨ ⟨ hm₁.choose, hm₁.choose_spec.1.1, hm₁.choose_spec.2 ⟩, fun y hy => if hy' : poly_P_neg y c ≤ poly_P_neg 0 c then hm₂ _ _ hy hy' rfl else by linarith [ hm₁.choose_spec.2, hm₂ _ _ le_rfl ( by linarith [ h_poly_pos 0 le_rfl ] ) rfl, h_poly_pos y hy ] ⟩;
      exact ⟨ m, by obtain ⟨ y, hy, rfl ⟩ := hm.1; exact h_poly_pos y hy, fun y hy => hm.2 _ ⟨ y, hy, rfl ⟩ ⟩;
  -- Choose $n$ large enough such that $12/n < m$.
  obtain ⟨N, hN⟩ : ∃ N : ℕ, ∀ n ≥ N, 12 / (n : ℝ) < m := by
    exact ⟨ ⌈12 / m⌉₊ + 1, fun n hn => by rw [ div_lt_iff₀ ] <;> nlinarith [ Nat.le_ceil ( 12 / m ), show ( n : ℝ ) ≥ ⌈12 / m⌉₊ + 1 by exact_mod_cast hn, mul_div_cancel₀ 12 hm.1.ne' ] ⟩;
  intro h_valid
  obtain ⟨n, hn⟩ := h_valid;
  obtain ⟨ x, hx ⟩ := hn ( n + N + 1 ) ( by linarith );
  have := condition_implies_poly_neg_le hx ( by linarith ) ( by linarith );
  exact not_lt_of_ge this ( lt_of_lt_of_le ( hN _ ( by linarith ) ) ( hm.2 _ ( Real.sqrt_nonneg _ ) ) )

/-
I generalize `y_star_neg_is_root` to `c <= c_crit`.
-/
lemma y_star_neg_is_root_crit {c : ℝ} (hc : c ≤ c_crit) : (y_star_neg c)^2 + c * (y_star_neg c) + c + 1 = 0 := by
  rw [ show y_star_neg c = ( -c + Real.sqrt ( c^2 - 4*c - 4 ) ) / 2 by rfl ] ; ring;
  rw [ Real.sq_sqrt ] <;> norm_num [ c_crit ] at * <;> nlinarith [ Real.sqrt_nonneg 2, Real.sq_sqrt zero_le_two ]

/-
I prove that `poly_P_neg` is non-positive at `y_star_neg` for `c <= c_neg`.
I use the auxiliary inequality `D^3 >= L^2` which holds for `c <= c_neg`.
I handle the case `L < 0` by squaring.
-/
lemma poly_P_neg_y_star_le_zero {c : ℝ} (hc : c ≤ c_neg) : poly_P_neg (y_star_neg c) c ≤ 0 := by
  -- Substitute y_star_neg c into the polynomial and simplify using the fact that (y_star_neg c)^2 + c*y_star_neg c + c + 1 = 0.
  have h_sub : poly_P_neg (y_star_neg c) c = c * (c^2 - 2*c - 8 + (c^2 - 4*c - 4) * y_star_neg c) := by
    unfold poly_P_neg y_star_neg; ring;
    rw [ show Real.sqrt ( -4 - c * 4 + c ^ 2 ) ^ 4 = ( Real.sqrt ( -4 - c * 4 + c ^ 2 ) ^ 2 ) ^ 2 by ring, show Real.sqrt ( -4 - c * 4 + c ^ 2 ) ^ 3 = ( Real.sqrt ( -4 - c * 4 + c ^ 2 ) ) * Real.sqrt ( -4 - c * 4 + c ^ 2 ) ^ 2 by ring, Real.sq_sqrt ] <;> nlinarith [ sq_nonneg ( c - 2 ), Real.sqrt_nonneg ( -4 - c * 4 + c ^ 2 ), Real.mul_self_sqrt ( show 0 <= -4 - c * 4 + c ^ 2 from by nlinarith [ sq_nonneg ( c - 2 ), Real.sqrt_nonneg ( -4 - c * 4 + c ^ 2 ), show c ≤ 2 - 4 * Real.sqrt 6 / 3 from hc, Real.sqrt_nonneg 6, Real.sq_sqrt ( show 6 ≥ 0 by norm_num ) ] ) ];
  -- Since $c \leq c_neg$, we have $c \leq -1$.
  have hc_neg : c ≤ -1 := by
    exact hc.trans ( by rw [ show c_neg = 2 - 4 * Real.sqrt 6 / 3 by rfl ] ; nlinarith [ Real.sqrt_nonneg 6, Real.sq_sqrt ( show 6 ≥ 0 by norm_num ) ] );
  -- Since $c \leq -1$, we have $c^2 - 2c - 8 + (c^2 - 4c - 4) * y_star_neg c \geq 0$.
  have h_expr_nonneg : c^2 - 2*c - 8 + (c^2 - 4*c - 4) * y_star_neg c ≥ 0 := by
    rw [ show y_star_neg c = ( -c + Real.sqrt ( c^2 - 4*c - 4 ) ) / 2 by rfl ];
    by_cases hc_neg : c ≤ 2 - 4 * Real.sqrt 6 / 3;
    · have h_expr_nonneg : (c^2 - 4*c - 4)^3 ≥ (c^3 - 6*c^2 + 16)^2 := by
        nlinarith [ Real.sqrt_nonneg 6, Real.sq_sqrt ( show 6 ≥ 0 by norm_num ) ];
      by_cases h_nonneg : c^2 - 4*c - 4 ≥ 0;
      · have h_sqrt_nonneg : (c^2 - 4*c - 4) * Real.sqrt (c^2 - 4*c - 4) ≥ |c^3 - 6*c^2 + 16| := by
          rw [ ← Real.sqrt_sq_eq_abs ];
          exact Real.sqrt_le_iff.mpr ⟨ by positivity, by nlinarith [ Real.mul_self_sqrt h_nonneg ] ⟩;
        cases abs_cases ( c ^ 3 - 6 * c ^ 2 + 16 ) <;> nlinarith;
      · exact False.elim <| h_nonneg <| by nlinarith [ Real.sqrt_nonneg 6, Real.sq_sqrt <| show 6 ≥ 0 by norm_num ] ;
    · exact?;
  exact h_sub.symm ▸ mul_nonpos_of_nonpos_of_nonneg ( by linarith ) h_expr_nonneg

/-
I define the witness vector `x_witness` and prove its sum is 1.
-/
noncomputable def x_witness (n : ℕ) (L : ℝ) : Fin n → ℝ :=
  fun i => if i.val = 0 then -L else (1 + L) / (n - 1)

lemma e1_witness {n : ℕ} {L : ℝ} (hn : n > 1) : e1 (x_witness n L) = 1 := by
  unfold x_witness e1;
  rcases n with ( _ | _ | n ) <;> norm_num [ Fin.sum_univ_succ ] at *;
  rw [ mul_div_cancel₀ ] <;> linarith

/-
I prove the auxiliary inequality `L + D sqrt(D) > 0` for `c < c_neg`.
I use the substitution `k = 2 - c` and `u = k^2`.
I show `u > 32/3`, which implies `D^3 > L^2`.
This implies `D sqrt(D) > -L` (when `L < 0`).
-/
lemma poly_P_neg_y_star_neg_aux {c : ℝ} (hc : c < c_neg) :
  -c^3 + 6*c^2 - 16 + (c^2 - 4*c - 4) * Real.sqrt (c^2 - 4*c - 4) > 0 := by
    by_cases hD : c^2 - 4*c - 4 > 0;
    · field_simp;
      rw [ show c_neg = 2 - 4 * Real.sqrt 6 / 3 by rfl ] at *;
      -- Squaring both sides to remove the square root.
      have h_sq : (c * (c - 4) - 4) ^ 2 * (c * (c - 4) - 4) > (c^2 * (-c + 6) - 16) ^ 2 := by
        nlinarith [ mul_pos ( sub_pos.mpr hc ) ( sub_pos.mpr hD ), Real.sqrt_nonneg 6, Real.sq_sqrt ( show 6 ≥ 0 by norm_num ) ];
      nlinarith [ show 0 < ( c * ( c - 4 ) - 4 ) * Real.sqrt ( c * ( c - 4 ) - 4 ) by exact mul_pos ( by nlinarith ) ( Real.sqrt_pos.mpr ( by nlinarith ) ), Real.mul_self_sqrt ( by nlinarith : 0 ≤ c * ( c - 4 ) - 4 ) ];
    · unfold c_neg at hc; nlinarith [ Real.sqrt_nonneg 6, Real.sq_sqrt ( show 6 ≥ 0 by norm_num ) ] ;

/-
I prove that `S2 (x_witness n L)` tends to `L^2` as `n` goes to infinity.
I use the explicit formula for `S2` and standard limit theorems.
-/
lemma tendsto_S2_witness {L : ℝ} : Filter.Tendsto (fun n => S2 (x_witness n L)) Filter.atTop (nhds (L^2)) := by
  -- We can split the sum into the first component and the rest.
  have h_split : ∀ n : ℕ, n > 1 → S2 (x_witness n L) = L^2 + (1 + L)^2 / (n - 1) := by
    unfold S2 x_witness; aesop;
    rcases n with ( _ | _ | n ) <;> norm_num [ Fin.sum_univ_succ ] at *;
    grind;
  rw [ Filter.tendsto_congr' ( Filter.eventuallyEq_of_mem ( Filter.Ioi_mem_atTop 1 ) fun n hn => h_split n hn ) ] ; exact le_trans ( tendsto_const_nhds.add <| tendsto_const_nhds.div_atTop <| Filter.tendsto_atTop_add_const_right _ _ <| tendsto_natCast_atTop_atTop ) <| by norm_num;

/-
I prove that `S3 (x_witness n L)` tends to `-L^3` as `n` goes to infinity.
-/
lemma tendsto_S3_witness {L : ℝ} : Filter.Tendsto (fun n => S3 (x_witness n L)) Filter.atTop (nhds (-L^3)) := by
  unfold S3
  unfold x_witness
  skip;
  -- Let's simplify the expression inside the sum.
  suffices h_simp : Filter.Tendsto (fun n : ℕ => (-L)^3 + (n - 1) * ((1 + L) / (n - 1))^3) Filter.atTop (𝓝 (-L^3)) by
    refine h_simp.congr' ?_;
    filter_upwards [ Filter.eventually_gt_atTop 1 ] with n hn ; rcases n with ( _ | _ | n ) <;> norm_num [ Fin.sum_univ_succ ] ; ring_nf ; aesop;
  field_simp;
  exact le_trans ( tendsto_const_nhds.add <| tendsto_const_nhds.div_atTop <| Filter.tendsto_pow_atTop ( by norm_num ) |> Filter.Tendsto.comp <| Filter.tendsto_atTop_add_const_right _ _ tendsto_natCast_atTop_atTop ) <| by norm_num;

/-
I prove that the expression in the condition tends to `poly_P_neg L c / 12` as `n` goes to infinity.
I use the limits of `S2` and `S3` for the witness vector.
-/
lemma tendsto_condition_expression {L c : ℝ} :
  Filter.Tendsto (fun n : ℕ => (1 - e2 (x_witness n L))^2 - 1 / (n : ℝ) - c * e3 (x_witness n L)) Filter.atTop (nhds (poly_P_neg L c / 12)) := by
    -- Substitute the expressions for e2 and e3 in terms of S2 and S3.
    suffices h_subst : Filter.Tendsto (fun n : ℕ => (1 - ((1 - S2 (x_witness n L)) / 2))^2 - 1 / (n : ℝ) - c * ((1 - 3 * S2 (x_witness n L) + 2 * S3 (x_witness n L)) / 6)) Filter.atTop (nhds ((poly_P_neg L c) / 12)) by
      refine' h_subst.congr' _;
      -- Substitute the identities for e2 and e3 into the second function.
      have h_eq : ∀ n : ℕ, n > 1 → (1 - e2 (x_witness n L))^2 - 1 / (n : ℝ) - c * e3 (x_witness n L) = (1 - (1 - S2 (x_witness n L)) / 2)^2 - 1 / (n : ℝ) - c * ((1 - 3 * S2 (x_witness n L) + 2 * S3 (x_witness n L)) / 6) := by
        -- Substitute the identities for e2 and e3 into the left-hand side.
        intro n hn
        simp [e2_eq, e3_eq_S2_S3];
        rw [ show e1 ( x_witness n L ) = 1 from e1_witness hn ] ; rw [ show e3 ( x_witness n L ) = ( 1 - 3 * S2 ( x_witness n L ) + 2 * S3 ( x_witness n L ) ) / 6 from by
                                                                        exact eq_of_sub_eq_zero ( by have := e3_eq_S2_S3 ( x_witness n L ) ( e1_witness hn ) ; norm_num at * ; linarith ) ] ; norm_num [ S2, S3 ] ;
      -- Apply the Filter.EventuallyEq.filter_eq_of_eventuallyEq lemma with N = 2.
      apply Filter.EventuallyEq.symm; exact Filter.eventually_atTop.mpr ⟨2, fun n hn => h_eq n (by linarith)⟩;
    -- Apply the fact that the limit of a difference is the difference of the limits, and the limit of a product is the product of the limits.
    have h_limits : Filter.Tendsto (fun n => (1 - ((1 - S2 (x_witness n L)) / 2))^2) Filter.atTop (nhds ((1 - ((1 - L^2) / 2))^2)) ∧ Filter.Tendsto (fun n => 1 / (n : ℝ)) Filter.atTop (nhds 0) ∧ Filter.Tendsto (fun n => c * ((1 - 3 * S2 (x_witness n L) + 2 * S3 (x_witness n L)) / 6)) Filter.atTop (nhds (c * ((1 - 3 * L^2 + 2 * (-L^3)) / 6))) := by
      -- Apply the fact that the limit of a difference is the difference of the limits, and the limit of a product is the product of the limits. Also, use the fact that the limit of a constant times a function is the constant times the limit of the function.
      have h_limits : Filter.Tendsto (fun n => S2 (x_witness n L)) Filter.atTop (nhds (L^2)) ∧ Filter.Tendsto (fun n => S3 (x_witness n L)) Filter.atTop (nhds (-L^3)) := by
        exact ⟨ tendsto_S2_witness, tendsto_S3_witness ⟩;
      exact ⟨ Filter.Tendsto.pow ( tendsto_const_nhds.sub ( Filter.Tendsto.div_const ( tendsto_const_nhds.sub h_limits.1 ) _ ) ) _, tendsto_const_nhds.div_atTop Filter.tendsto_id, tendsto_const_nhds.mul ( Filter.Tendsto.div_const ( Filter.Tendsto.add ( tendsto_const_nhds.sub ( tendsto_const_nhds.mul h_limits.1 ) ) ( tendsto_const_nhds.mul h_limits.2 ) ) _ ) ⟩;
    convert Filter.Tendsto.sub ( Filter.Tendsto.sub h_limits.1 ( h_limits.2.1.comp tendsto_natCast_atTop_atTop ) ) h_limits.2.2 using 2 ; ring;
    unfold poly_P_neg; ring;

/-
I prove that `poly_P_neg` is strictly negative at `y_star_neg` for `c < c_neg`.
I use the auxiliary inequality `L + D sqrt(D) > 0` which holds for `c < c_neg`.
I multiply by 2 and expand terms to match the auxiliary inequality.
-/
lemma poly_P_neg_y_star_lt_zero {c : ℝ} (hc : c < c_neg) : poly_P_neg (y_star_neg c) c < 0 := by
  -- Since $c < c_neg$, we know that $c$ is negative and $y_star_neg c$ is positive. Therefore, $c * (c^2 - 2c - 8 + (c^2 - 4c - 4) * y_star_neg c)$ is negative.
  have h_neg : c < 0 ∧ y_star_neg c > 0 := by
    -- Since $c < c_neg$ and $c_neg$ is negative, $c$ must also be negative.
    have hc_neg : c < 0 := by
      exact hc.trans_le ( show c_neg ≤ 0 by rw [ show c_neg = 2 - 4 * Real.sqrt 6 / 3 by rfl ] ; nlinarith [ Real.sqrt_nonneg 6, Real.sq_sqrt ( show 6 ≥ 0 by norm_num ) ] );
    exact ⟨ hc_neg, by rw [ show y_star_neg c = ( -c + Real.sqrt ( c^2 - 4*c - 4 ) ) / 2 from rfl ] ; exact div_pos ( by nlinarith [ Real.sqrt_nonneg ( c^2 - 4*c - 4 ), Real.mul_self_sqrt ( show 0 <= c^2 - 4*c - 4 by nlinarith [ show c_neg = 2 - 4 * Real.sqrt 6 / 3 by rfl, Real.sqrt_nonneg 6, Real.sq_sqrt ( show 6 ≥ 0 by norm_num ) ] ) ] ) zero_lt_two ⟩;
  have h_poly_neg : c * (c^2 - 2*c - 8 + (c^2 - 4*c - 4) * y_star_neg c) < 0 := by
    have := poly_P_neg_y_star_neg_aux hc;
    unfold y_star_neg; ring_nf at *; nlinarith [ Real.sqrt_nonneg ( c ^ 2 - 4 * c - 4 ), Real.mul_self_sqrt ( show 0 <= c ^ 2 - 4 * c - 4 by nlinarith [ show c_neg = 2 - 4 * Real.sqrt 6 / 3 by rfl, Real.sqrt_nonneg 6, Real.sq_sqrt ( show 6 ≥ 0 by norm_num ) ] ) ] ;
  -- By combining the results from h_poly_neg and poly_P_neg_y_star_eq, we conclude that poly_P_neg (y_star_neg c) c is less than zero.
  rw [poly_P_neg_y_star_eq] at *; exact h_poly_neg;
  contrapose! hc; unfold c_neg at *; nlinarith [ Real.sqrt_nonneg 6, Real.sq_sqrt ( show 6 ≥ 0 by norm_num ) ] ;

/-
I prove `valid_of_lt_c_neg` using the limit argument.
I show `poly_P_neg (L) < 0` and that the condition expression tends to `poly_P_neg (L) / 12`.
I use the fact that `poly_P_neg L c < 0` to show the condition holds for large `n`.
-/
lemma valid_of_lt_c_neg {c : ℝ} (hc : c < c_neg) : is_valid_lambda c := by
  -- Since $poly_P_neg (y_star_neg c) c < 0$, we can choose $n$ large enough such that the condition expression is less than 0.
  have h_cond : ∃ N : ℕ, ∀ n ≥ N, (1 - e2 (x_witness n (y_star_neg c)))^2 - 1 / (n : ℝ) - c * e3 (x_witness n (y_star_neg c)) < 0 := by
    have h_limit : Filter.Tendsto (fun n : ℕ => (1 - e2 (x_witness n (y_star_neg c)))^2 - 1 / (n : ℝ) - c * e3 (x_witness n (y_star_neg c))) Filter.atTop (nhds (poly_P_neg (y_star_neg c) c / 12)) := by
      convert tendsto_condition_expression using 1;
    exact Filter.eventually_atTop.mp ( h_limit.eventually ( gt_mem_nhds <| div_neg_of_neg_of_pos ( poly_P_neg_y_star_lt_zero hc ) <| by norm_num ) );
  -- By definition of `is_valid_lambda`, we need to show that there exists an N such that for all n ≥ N, there exists an x satisfying the condition.
  obtain ⟨N, hN⟩ := h_cond;
  use N + 2; intros n hn;
  use x_witness n (y_star_neg c);
  aesop;
  constructor <;> norm_num;
  · exact e1_witness ( by linarith );
  · -- Substitute the expression for the sum of squared differences into the inequality.
    have h_sum_sq_diff : ∑ i : Fin n, ∑ j : Fin n, (if i < j then (x_witness n (y_star_neg c) i - x_witness n (y_star_neg c) j) ^ 2 else 0) = n * S2 (x_witness n (y_star_neg c)) - (e1 (x_witness n (y_star_neg c)))^2 := by
      convert sum_sq_diff_eq _ using 1;
    have h_e2 : e2 (x_witness n (y_star_neg c)) = ((e1 (x_witness n (y_star_neg c)))^2 - S2 (x_witness n (y_star_neg c))) / 2 := by
      -- Apply the formula from the problem statement to x_witness n (y_star_neg c).
      apply e2_eq;
    have h_e1 : e1 (x_witness n (y_star_neg c)) = 1 := by
      exact e1_witness ( by linarith );
    aesop;
    have := hN n ( by linarith ) ; rw [ h_e2 ] at this; nlinarith [ inv_mul_cancel_left₀ ( by norm_cast; linarith : ( n : ℝ ) ≠ 0 ) ( S2 ( x_witness n ( y_star_neg c ) ) ) ] ;

/-
I prove that `poly_P_neg` is zero at `y_star_neg c_neg`.
I verify the algebraic identity `D^3 = L^2` for `c_neg`.
I show `L < 0` and `D >= 0`.
This implies `L + D sqrt(D) = 0`.
-/
lemma poly_P_neg_c_neg_eq_zero : poly_P_neg (y_star_neg c_neg) c_neg = 0 := by
  -- Substitute the values of `c_neg` and `y_star_neg c_neg` into the expression for `poly_P_neg`.
  simp [poly_P_neg, y_star_neg];
  rw [ show c_neg = 2 - 4 * Real.sqrt 6 / 3 by rfl ] ; ring;
  norm_num [ pow_three ] ; ring;
  norm_num [ show ( Real.sqrt 6 ) ^ 4 = ( Real.sqrt 6 ^ 2 ) ^ 2 by ring, show ( Real.sqrt 8 ) ^ 4 = ( Real.sqrt 8 ^ 2 ) ^ 2 by ring, show ( Real.sqrt 3 ) ^ 4 = ( Real.sqrt 3 ^ 2 ) ^ 2 by ring, pow_three ] ; ring;
  rw [ show ( 8 : ℝ ) = 4 * 2 by norm_num, Real.sqrt_mul ] <;> norm_num ; ring_nf ; norm_num [ ← Real.sqrt_div_self ] ; ring_nf ; norm_num;
  norm_num [ pow_three ] ; rw [ show ( 6 : ℝ ) = 3 * 2 by norm_num, Real.sqrt_mul ( by norm_num ) ] ; ring ; norm_num;

/-
I define the second derivative of `poly_P_neg` and prove it is positive at `y_star_neg c` for `c <= -1`.
-/
def poly_P_neg_deriv2 (y c : ℝ) : ℝ := 36 * y^2 + 24 * c * y + (12 * c + 12)

lemma poly_P_neg_deriv2_pos_at_y_star {c : ℝ} (hc : c ≤ -1) (h_root : (y_star_neg c)^2 + c * (y_star_neg c) + c + 1 = 0) :
  poly_P_neg_deriv2 (y_star_neg c) c > 0 := by
    unfold poly_P_neg_deriv2;
    unfold y_star_neg at *;
    nlinarith [ Real.sqrt_nonneg ( c ^ 2 - 4 * c - 4 ) ]

/-
I prove that the coefficient of the `1/n` term in the expansion is positive at `c_neg`.
I use numerical bounds for `c` and `L`.
I fixed the syntax error by putting the expression directly in the statement.
-/
lemma coeff_pos_at_c_neg :
  -6 * c_neg * (y_star_neg c_neg) * (1 + y_star_neg c_neg)^2 - 12 > 0 := by
    rw [ y_star_neg ];
    rw [ show c_neg = 2 - 4 * Real.sqrt 6 / 3 by rfl ] ; ring ; norm_num;
    -- Simplify the terms involving square roots and fractions.
    field_simp;
    norm_num [ pow_three ] ; ring_nf ; norm_num;
    rw [ show ( Real.sqrt 6 ) ^ 4 = ( Real.sqrt 6 ^ 2 ) ^ 2 by ring, Real.sq_sqrt ] <;> norm_num ; nlinarith [ Real.sqrt_nonneg 3, Real.sqrt_nonneg 6, Real.sqrt_nonneg 8, Real.sq_sqrt ( show 0 ≤ 3 by norm_num ), Real.sq_sqrt ( show 0 ≤ 6 by norm_num ), Real.sq_sqrt ( show 0 ≤ 8 by norm_num ), mul_pos ( Real.sqrt_pos.mpr ( show 0 < 3 by norm_num ) ) ( Real.sqrt_pos.mpr ( show 0 < 6 by norm_num ) ), mul_pos ( Real.sqrt_pos.mpr ( show 0 < 3 by norm_num ) ) ( Real.sqrt_pos.mpr ( show 0 < 8 by norm_num ) ), mul_pos ( Real.sqrt_pos.mpr ( show 0 < 6 by norm_num ) ) ( Real.sqrt_pos.mpr ( show 0 < 8 by norm_num ) ) ]

/-
I define `coeff_n` and prove it is greater than 1 using the previously proved `coeff_pos_at_c_neg`.
-/
noncomputable def coeff_n (c : ℝ) : ℝ := -c * y_star_neg c / 2 * (1 + y_star_neg c)^2

lemma coeff_n_gt_one : coeff_n c_neg > 1 := by
  have h_pos : -6 * c_neg * (y_star_neg c_neg) * (1 + y_star_neg c_neg)^2 - 12 > 0 := coeff_pos_at_c_neg
  unfold coeff_n
  linarith

/-
I define `F_witness` which represents the condition inequality for the witness vector.
-/
noncomputable def F_witness (n : ℕ) (c : ℝ) : ℝ :=
  let L := y_star_neg c
  let x := x_witness n L
  (1 - e2 x)^2 - 1 / (n : ℝ) - c * e3 x

/-
I define `limit_val` and prove it is greater than 1 for `c_neg`.
-/
noncomputable def limit_val (c : ℝ) : ℝ := -c * y_star_neg c / 2 * (1 + y_star_neg c)^2

lemma limit_val_gt_one : limit_val c_neg > 1 := by
  have h := coeff_pos_at_c_neg
  unfold limit_val
  linarith

/-
I prove `coeff_n_gt_one` (renamed to `coeff_n_gt_one_proof`) using numerical bounds.
-/
lemma coeff_n_gt_one_proof : coeff_n c_neg > 1 := by
  exact?

/-
I define `coeff_n_val` and prove it is greater than 1 for `c_neg` using numerical bounds.
-/
noncomputable def coeff_n_val (c : ℝ) : ℝ := -c * y_star_neg c / 2 * (1 + y_star_neg c)^2

lemma coeff_n_val_gt_one : coeff_n_val c_neg > 1 := by
  convert coeff_n_gt_one using 1

/-
I prove that `(n-1) * (S2 - L^2)` tends to `(1+L)^2`.
-/
lemma tendsto_scaled_S2_diff {L : ℝ} :
  Filter.Tendsto (fun n : ℕ => ((n : ℝ) - 1) * (S2 (x_witness n L) - L^2)) Filter.atTop (nhds ((1 + L)^2)) := by
    unfold S2 x_witness;
    rw [ Filter.tendsto_congr' ];
    swap;
    filter_upwards [ Filter.eventually_gt_atTop 1 ] with n hn;
    any_goals exact fun n => ( 1 + L ) ^ 2;
    · rcases n with ( _ | _ | n ) <;> norm_num [ Fin.sum_univ_succ ] at *;
      field_simp;
    · exact tendsto_const_nhds

/-
I prove that `(n-1) * (S3 - (-L^3))` tends to 0.
-/
lemma tendsto_scaled_S3_diff {L : ℝ} :
  Filter.Tendsto (fun n : ℕ => ((n : ℝ) - 1) * (S3 (x_witness n L) - (-L^3))) Filter.atTop (nhds 0) := by
    -- We can simplify the expression inside the limit.
    have h_simplify : ∀ n : ℕ, n > 1 → (n - 1) * (S3 (x_witness n L) + L^3) = (1 + L)^3 / (n - 1) := by
      intros n hn_gt_1
      simp [S3, x_witness];
      rcases n with ( _ | _ | n ) <;> norm_num [ Fin.sum_univ_succ ] at *;
      -- Combine like terms and simplify the expression.
      field_simp
      ring;
    rw [ Filter.tendsto_congr' ( by filter_upwards [ Filter.eventually_gt_atTop 1 ] with n hn; rw [ show ( S3 ( x_witness n L ) - -L ^ 3 ) = S3 ( x_witness n L ) + L ^ 3 by ring, h_simplify n hn ] ) ] ; simpa using tendsto_const_nhds.div_atTop ( Filter.tendsto_atTop_add_const_right _ _ tendsto_natCast_atTop_atTop ) ;