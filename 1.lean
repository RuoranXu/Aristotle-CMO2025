/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
-/

/-
We define the sets A and B and the property of being a solution.
We prove that the only polynomials mapping A into B are the constant polynomials with value in B.
The proof relies on the asymptotic behavior of polynomials: a non-constant polynomial maps a sector of angle $\alpha$ to a sector of angle roughly $n\alpha$ at infinity.
Since B is a strip, it subtends an angle of 0 at infinity, so the degree must be 0.
Thus the polynomial is constant.
The constant must be in B.
-/

import Mathlib

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

#check Complex.arg_zero
#check Complex.arg_le_pi
#check Complex.neg_pi_lt_arg

/-
The set A is the sector of complex numbers with argument between 0 and pi/41. The set B is the strip of complex numbers z such that |Re(z) - Im(z)| < 2025. The only polynomials mapping A into B are the constants in B.
-/
def SetA : Set ℂ := { z | 0 ≤ z.arg ∧ z.arg ≤ Real.pi / 41 }

def SetB : Set ℂ := { z | |z.re - z.im| < 2025 }

def IsSolution (P : Polynomial ℂ) : Prop := ∀ z ∈ SetA, (P.eval z) ∈ SetB

theorem solution_set_is_constants :
  ∀ P : Polynomial ℂ, IsSolution P ↔ ∃ c ∈ SetB, P = Polynomial.C c := by
    -- Let's unfold the definition of IsSolution.
    intro P
    constructor
    intro hP
    -- Assume P is a solution. We need to show that P is constant.
    have h_const : ∃ c : ℂ, P = Polynomial.C c := by
      -- Assume that P is not constant. Then its degree is positive.
      by_contra h_nonconst
      have h_deg : 0 < P.degree := by
        -- Since P is not constant, its degree must be greater than zero.
        apply lt_of_not_ge; intro h_deg_zero; exact h_nonconst ⟨P.coeff 0, Polynomial.eq_C_of_degree_le_zero h_deg_zero⟩;
      -- Consider the limit of $\frac{P(r e^{i \theta})}{r^{\deg P}}$ as $r \to \infty$ for $\theta \in [0, \frac{\pi}{41}]$.
      have h_lim : ∀ θ ∈ Set.Icc 0 (Real.pi / 41), Filter.Tendsto (fun r : ℝ => P.eval (r * Complex.exp (θ * Complex.I)) / r ^ P.natDegree) Filter.atTop (nhds (P.leadingCoeff * Complex.exp (θ * P.natDegree * Complex.I))) := by
        intro θ hθ
        have h_lim_aux : Filter.Tendsto (fun r : ℝ => (∑ k ∈ Finset.range (P.natDegree + 1), P.coeff k * (r * Complex.exp (θ * Complex.I)) ^ k) / r ^ P.natDegree) Filter.atTop (nhds (P.leadingCoeff * Complex.exp (θ * P.natDegree * Complex.I))) := by
          -- We can factor out $r^{P.natDegree}$ from the numerator and denominator.
          suffices h_factor : Filter.Tendsto (fun r : ℝ => (∑ k ∈ Finset.range (P.natDegree + 1), P.coeff k * Complex.exp (θ * k * Complex.I) / r ^ (P.natDegree - k))) Filter.atTop (nhds (P.leadingCoeff * Complex.exp (θ * P.natDegree * Complex.I))) by
            -- By simplifying, we can see that the two expressions are equivalent.
            have h_equiv : ∀ r : ℝ, r ≠ 0 → (∑ k ∈ Finset.range (P.natDegree + 1), P.coeff k * (r * Complex.exp (θ * Complex.I)) ^ k) / r ^ P.natDegree = ∑ k ∈ Finset.range (P.natDegree + 1), P.coeff k * Complex.exp (θ * k * Complex.I) / r ^ (P.natDegree - k) := by
              intro r hr; rw [ Finset.sum_div _ _ _ ] ; refine' Finset.sum_congr rfl fun i hi => _ ; rw [ div_eq_div_iff ] <;> simp +decide [ hr, mul_pow, ← Complex.exp_nat_mul, mul_assoc, mul_comm, mul_left_comm ] ;
              rw [ show ( r : ℂ ) ^ P.natDegree = ( r : ℂ ) ^ i * ( r : ℂ ) ^ ( P.natDegree - i ) by rw [ ← pow_add, Nat.add_sub_of_le ( Finset.mem_range_succ_iff.mp hi ) ] ] ; ring;
            exact h_factor.congr' ( by filter_upwards [ Filter.eventually_ne_atTop 0 ] with r hr; rw [ h_equiv r hr ] );
          -- As $r \to \infty$, the terms with $k < P.natDegree$ tend to $0$.
          have h_zero : ∀ k < P.natDegree, Filter.Tendsto (fun r : ℝ => P.coeff k * Complex.exp (θ * k * Complex.I) / r ^ (P.natDegree - k)) Filter.atTop (nhds 0) := by
            intro k hk; rw [ tendsto_zero_iff_norm_tendsto_zero ] ; aesop;
            exact tendsto_const_nhds.div_atTop ( Filter.tendsto_pow_atTop ( Nat.sub_ne_zero_of_lt hk ) |> Filter.Tendsto.comp <| Filter.tendsto_abs_atTop_atTop );
          simpa [ Finset.sum_range_succ ] using Filter.Tendsto.add ( tendsto_finset_sum _ fun i hi => h_zero i <| Finset.mem_range.mp hi ) tendsto_const_nhds;
        simpa only [ Polynomial.eval_eq_sum_range ] using h_lim_aux;
      -- Since $P$ maps $A$ into $B$, for any $z \in A$, we have $|\Re(P(z)) - \Im(P(z))| < 2025$. Taking the limit as $r \to \infty$, we get $|\Re(P.leadingCoeff * e^{i\theta \deg(P)}) - \Im(P.leadingCoeff * e^{i\theta \deg(P)})| = 0$ for all $\theta \in [0, \frac{\pi}{41}]$.
      have h_zero : ∀ θ ∈ Set.Icc 0 (Real.pi / 41), Complex.re (P.leadingCoeff * Complex.exp (θ * P.natDegree * Complex.I)) = Complex.im (P.leadingCoeff * Complex.exp (θ * P.natDegree * Complex.I)) := by
        intros θ hθ
        have h_abs : ∀ r : ℝ, r > 0 → |Complex.re (P.eval (r * Complex.exp (θ * Complex.I))) - Complex.im (P.eval (r * Complex.exp (θ * Complex.I)))| < 2025 := by
          intros r hr
          have hz : r * Complex.exp (θ * Complex.I) ∈ SetA := by
            unfold SetA; aesop;
            · exact Real.sin_nonneg_of_nonneg_of_le_pi left ( by linarith );
            · rw [ Complex.arg ] ; aesop;
              · rw [ abs_of_pos hr, mul_div_cancel_left₀ _ hr.ne' ];
                rw [ Real.arcsin_sin ] <;> linarith [ Real.pi_pos ];
              · exact False.elim <| h.not_le <| Real.cos_nonneg_of_mem_Icc ⟨ by linarith, by linarith ⟩;
              · linarith [ Real.sin_nonneg_of_nonneg_of_le_pi left ( by linarith ) ];
          exact?;
        -- Taking the limit as $r \to \infty$ in $|\Re(P(r e^{i \theta})) - \Im(P(r e^{i \theta}))| < 2025$, we get $|\Re(P.leadingCoeff * e^{i\theta \deg(P)}) - \Im(P.leadingCoeff * e^{i\theta \deg(P)})| = 0$.
        have h_lim_zero : Filter.Tendsto (fun r : ℝ => (Complex.re (P.eval (r * Complex.exp (θ * Complex.I))) - Complex.im (P.eval (r * Complex.exp (θ * Complex.I)))) / r ^ P.natDegree) Filter.atTop (nhds 0) := by
          refine' squeeze_zero_norm' _ _;
          use fun r => 2025 / r ^ P.natDegree;
          · filter_upwards [ Filter.eventually_gt_atTop 0 ] with r hr using by simpa [ abs_div, abs_of_nonneg hr.le ] using div_le_div_of_nonneg_right ( le_of_lt ( h_abs r hr ) ) ( pow_nonneg hr.le _ ) ;
          · exact tendsto_const_nhds.div_atTop ( by exact Filter.tendsto_pow_atTop ( by linarith [ Polynomial.natDegree_pos_iff_degree_pos.mpr h_deg ] ) );
        have h_lim_zero : Filter.Tendsto (fun r : ℝ => Complex.re (P.eval (r * Complex.exp (θ * Complex.I)) / r ^ P.natDegree) - Complex.im (P.eval (r * Complex.exp (θ * Complex.I)) / r ^ P.natDegree)) Filter.atTop (nhds 0) := by
          refine' h_lim_zero.congr' _;
          filter_upwards [ Filter.eventually_gt_atTop 0 ] with r hr ; norm_num [ hr.ne', Complex.div_re, Complex.div_im ] ; ring;
          norm_cast; norm_num [ pow_mul, hr.ne' ] ; ring;
          norm_num [ pow_mul, hr.ne' ];
          simp +decide [ sq, mul_assoc, hr.ne' ];
        have := h_lim_zero.sub ( Filter.Tendsto.comp ( Complex.continuous_re.continuousAt.sub Complex.continuous_im.continuousAt ) ( h_lim θ hθ ) ) ; aesop;
        linarith;
      have := h_zero 0 ⟨ by norm_num, by positivity ⟩ ; have := h_zero ( Real.pi / 41 ) ⟨ by positivity, by linarith [ Real.pi_pos ] ⟩ ; norm_num [ Complex.exp_re, Complex.exp_im ] at * ; aesop;
      by_cases h : P.leadingCoeff.im = 0 <;> simp_all +decide [ sub_eq_add_neg, add_assoc ];
      · -- If the leading coefficient is zero, then P is the zero polynomial, which contradicts the assumption that P is non-constant.
        have h_zero_poly : P = 0 := by
          exact Polynomial.leadingCoeff_eq_zero.mp ( Complex.ext this_1 h );
        aesop;
      · -- Since $P.leadingCoeff.im \neq 0$, we can divide both sides of the equation by $P.leadingCoeff.im$ to get $\cos(\theta \deg(P)) - \sin(\theta \deg(P)) = \sin(\theta \deg(P)) + \cos(\theta \deg(P))$.
        have h_div : ∀ θ ∈ Set.Icc 0 (Real.pi / 41), Real.cos (θ * P.natDegree) - Real.sin (θ * P.natDegree) = Real.sin (θ * P.natDegree) + Real.cos (θ * P.natDegree) := by
          exact fun θ hθ => mul_left_cancel₀ h <| by linarith [ h_zero θ hθ.1 hθ.2 ] ;
        specialize h_div ( Real.pi / 41 / P.natDegree ) ⟨ by positivity, by rw [ div_le_iff₀ ( Nat.cast_pos.mpr <| Polynomial.natDegree_pos_iff_degree_pos.mpr h_deg ) ] ; nlinarith [ Real.pi_pos, show ( P.natDegree : ℝ ) ≥ 1 by exact_mod_cast Polynomial.natDegree_pos_iff_degree_pos.mpr h_deg ] ⟩ ; norm_num [ mul_div_cancel₀, h, Polynomial.natDegree_pos_iff_degree_pos.mpr h_deg ] at h_div;
        rw [ div_mul_cancel₀ _ ( Nat.cast_ne_zero.mpr <| ne_of_gt <| Polynomial.natDegree_pos_iff_degree_pos.mpr h_deg ) ] at h_div ; linarith [ Real.sin_pos_of_pos_of_lt_pi ( show 0 < Real.pi / 41 by positivity ) ( by linarith [ Real.pi_pos ] ) ] ;
    obtain ⟨c, hc⟩ := h_const
    -- Since P is constant, we need to show that c is in B.
    have h_c_in_B : c ∈ SetB := by
      have := hP ( Complex.ofReal 1 ) ; aesop;
      -- Since $1 \in \text{SetA}$, we can apply the hypothesis $hP$ to conclude that $c \in \text{SetB}$.
      apply this; exact ⟨by norm_num, by norm_num; linarith [Real.pi_pos]⟩
    use c, h_c_in_B, hc
    intro hP
    -- Assume P is constant and in B. We need to show that P is a solution.
    obtain ⟨c, hcB, rfl⟩ := hP
    simp [SetB] at hcB
    exact (by
    exact fun x hx => by aesop;)

/-
As r goes to infinity, P(r * exp(i * theta)) / r^degree converges to leading_coeff * exp(i * degree * theta).
-/
lemma poly_asymptotic (P : Polynomial ℂ) (θ : ℝ) :
  Filter.Tendsto (fun r : ℝ => P.eval (r * Complex.exp (θ * Complex.I)) / (r ^ P.natDegree)) Filter.atTop (nhds (P.leadingCoeff * Complex.exp (P.natDegree * θ * Complex.I))) := by
    -- We can write $P(z)$ as $a_n z^n + \sum_{k=0}^{n-1} a_k z^k$.
    have h_poly_split : ∀ r : ℝ, P.eval (r * Complex.exp (θ * Complex.I)) = P.leadingCoeff * (r * Complex.exp (θ * Complex.I)) ^ P.natDegree + ∑ k ∈ Finset.range P.natDegree, P.coeff k * (r * Complex.exp (θ * Complex.I)) ^ k := by
      intro r; rw [ Polynomial.eval_eq_sum_range ] ; rw [ Finset.sum_range_succ_comm ] ; aesop;
    -- Dividing both sides of the equation by $r^n$, we get $\frac{P(r e^{i\theta})}{r^n} = P.leadingCoeff e^{in\theta} + \sum_{k=0}^{n-1} P.coeff k \frac{e^{ik\theta}}{r^{n-k}}$.
    have h_poly_div : ∀ r : ℝ, r ≠ 0 → (P.eval (r * Complex.exp (θ * Complex.I))) / r ^ P.natDegree = P.leadingCoeff * Complex.exp (P.natDegree * θ * Complex.I) + ∑ k ∈ Finset.range P.natDegree, P.coeff k * (Complex.exp (k * θ * Complex.I)) / r ^ (P.natDegree - k) := by
      intro r hr; rw [ h_poly_split r, div_eq_iff ( by aesop ) ] ; simp +decide [ Finset.sum_mul _ _ _, mul_pow, ← Complex.exp_nat_mul ] ; ring;
      simp +decide [ Finset.mul_sum _ _ _, mul_assoc, mul_comm, mul_left_comm, pow_add, hr ];
      -- By simplifying the exponents, we can see that each term in the sum on the right is equal to the corresponding term on the left.
      have h_exp : ∀ x ∈ Finset.range P.natDegree, (r : ℂ) ^ x = (r : ℂ) ^ P.natDegree * ((r : ℂ) ^ (P.natDegree - x))⁻¹ := by
        exact fun x hx => eq_div_of_mul_eq ( pow_ne_zero _ <| Complex.ofReal_ne_zero.mpr hr ) <| by rw [ ← pow_add, Nat.add_sub_of_le <| Finset.mem_range_le hx ] ;
      exact Finset.sum_congr rfl fun x hx => by rw [ h_exp x hx ] ; ring;
    rw [ Filter.tendsto_congr' ( by filter_upwards [ Filter.eventually_ne_atTop 0 ] with r hr; aesop ) ];
    exact le_trans ( tendsto_const_nhds.add <| tendsto_finset_sum _ fun i hi => tendsto_zero_iff_norm_tendsto_zero.mpr <| by simpa using tendsto_const_nhds.div_atTop <| Filter.tendsto_pow_atTop ( Nat.sub_ne_zero_of_lt <| Finset.mem_range.mp hi ) |> Filter.Tendsto.comp <| tendsto_norm_atTop_atTop ) <| by norm_num;

/-
If a sequence of complex numbers in the strip B goes to infinity in norm, then the absolute difference between the cosine and sine of their arguments goes to 0.
-/
lemma strip_asymptotic_arg {z : ℕ → ℂ} (h_in_B : ∀ k, z k ∈ SetB) (h_norm : Filter.Tendsto (fun k => ‖z k‖) Filter.atTop Filter.atTop) :
  Filter.Tendsto (fun k => |Real.cos (z k).arg - Real.sin (z k).arg|) Filter.atTop (nhds 0) := by
    -- Given that $|z_k| \to \infty$ and $|z_k.re - z_k.im| < 2025$, we have $\frac{|z_k.re - z_k.im|}{|z_k|} \to 0$.
    have h_frac_zero : Filter.Tendsto (fun k => |Complex.re (z k) - Complex.im (z k)| / ‖z k‖) Filter.atTop (nhds 0) := by
      exact squeeze_zero ( fun k => div_nonneg ( abs_nonneg _ ) ( norm_nonneg _ ) ) ( fun k => div_le_div_of_nonneg_right ( le_of_lt ( h_in_B k ) ) ( norm_nonneg _ ) ) ( tendsto_const_nhds.div_atTop h_norm );
    refine' squeeze_zero_norm' _ h_frac_zero;
    filter_upwards [ h_norm.eventually_gt_atTop 0 ] with k hk ; rw [ Complex.cos_arg, Complex.sin_arg ] <;> aesop;
    rw [ div_sub_div_same, abs_div, abs_of_nonneg ( norm_nonneg _ ) ]

/-
If a polynomial maps the sector A into the strip B, its degree must be 0.
-/
theorem degree_eq_zero_of_maps_sector_to_strip (P : Polynomial ℂ)
  (h : ∀ z ∈ SetA, P.eval z ∈ SetB) : P.natDegree = 0 := by
    -- Apply the lemma that states P is a solution if and only if it's a constant polynomial in B.
    have h_const : ∃ c ∈ SetB, P = Polynomial.C c := by
      exact?;
    aesop