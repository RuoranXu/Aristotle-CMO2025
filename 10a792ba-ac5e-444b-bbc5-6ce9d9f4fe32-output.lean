/-
Sorry, Aristotle was unable to complete the task in time.
-/
/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
-/

import Mathlib

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Let convex quadrilateral ABCD be inscribed in a circle with center O and radius 1, satisfying angle ABC < angle BCD < 90. Let P be the intersection of lines BA and CD, and Q be the intersection of diagonals AC and BD. It is known that there exists a point K on segment BC such that P, A, K, D are concyclic, and KB * KC = 1/2 OP^2. Draw the perpendicular from Q to BC, which intersects line OP at point T. (1) Find all possible values of OP; (2) Find all possible values of TB + TC.
-/
open Complex Real EuclideanGeometry


-- We define a helper for collinearity of complex numbers over reals
def collinear_complex (a b c : ℂ) : Prop :=
  Collinear ℝ {a, b, c}

structure ProblemSetup where
  A : ℂ
  B : ℂ
  C : ℂ
  D : ℂ
  P : ℂ
  Q : ℂ
  K : ℂ
  T : ℂ
  -- A, B, C, D on unit circle
  hA : norm A = 1
  hB : norm B = 1
  hC : norm C = 1
  hD : norm D = 1
  -- Convex quadrilateral ABCD
  -- We assume A, B, C, D are distinct and in counterclockwise order
  -- angle ABC < angle BCD < 90
  h_angle_ABC : angle A B C < angle B C D
  h_angle_BCD : angle B C D < π / 2
  -- P is intersection of lines BA and CD
  hP_collinear_AB : collinear_complex P A B
  hP_collinear_CD : collinear_complex P C D
  hP_not_A : P ≠ A
  -- Q is intersection of diagonals AC and BD
  hQ_collinear_AC : collinear_complex Q A C
  hQ_collinear_BD : collinear_complex Q B D
  -- K on segment BC
  hK_on_segment : ∃ t : ℝ, 0 ≤ t ∧ t ≤ 1 ∧ K = B + t • (C - B)
  -- P, A, K, D concyclic
  h_concyclic : Concyclic {P, A, K, D}
  -- KB * KC = 1/2 OP^2
  h_power : dist K B * dist K C = 1/2 * (norm P)^2
  -- QT perpendicular to BC
  h_perp : ((Q - T) * star (B - C)).re = 0
  -- T on line OP
  hT_on_OP : collinear_complex 0 T P

def possible_OP_values : Set ℝ :=
  { r | ∃ setup : ProblemSetup, norm setup.P = r }

def possible_TB_TC_values : Set ℝ :=
  { s | ∃ setup : ProblemSetup, dist setup.T setup.B + dist setup.T setup.C = s }

/-
The product of distances KB and KC is equal to 1 minus the square of the distance OK.
-/
lemma BK_mul_KC_eq_one_sub_OK_sq (setup : ProblemSetup) :
  dist setup.K setup.B * dist setup.K setup.C = 1 - (dist setup.K 0)^2 := by
    -- Let's express the coordinates of K in terms of B and C.
    obtain ⟨t, ht⟩ : ∃ t : ℝ, 0 ≤ t ∧ t ≤ 1 ∧ setup.K = setup.B + t • (setup.C - setup.B) := by
      exact setup.hK_on_segment;
    -- Substitute the expressions for the distances and simplify.
    have h_dist_KB : dist setup.K setup.B = t * dist setup.B setup.C := by
      norm_num [ ht, dist_eq_norm ];
      rw [ abs_of_nonneg ht.1, norm_sub_rev ]
    have h_dist_KC : dist setup.K setup.C = (1 - t) * dist setup.B setup.C := by
      simp_all +decide [ dist_eq_norm ];
      rw [ show setup.B + ( t : ℂ ) * ( setup.C - setup.B ) - setup.C = ( 1 - t ) * ( setup.B - setup.C ) by ring ] ; norm_num [ abs_of_nonneg, ht.1, ht.2.1 ];
      exact Or.inl <| mod_cast abs_of_nonneg <| sub_nonneg_of_le ht.2.1
    have h_dist_OK : dist setup.K 0 = Real.sqrt (1 - t * (1 - t) * dist setup.B setup.C ^ 2) := by
      norm_num [ Complex.normSq, Complex.norm_def, dist_eq_norm ] at * ; aesop;
      rw [ Real.sq_sqrt ( add_nonneg ( mul_self_nonneg _ ) ( mul_self_nonneg _ ) ) ] ; ring;
      rw [ show setup.B.re ^ 2 = 1 - setup.B.im ^ 2 by { have := setup.hB; norm_num [ Complex.normSq, Complex.norm_def ] at this; nlinarith } ] ; rw [ show setup.C.re ^ 2 = 1 - setup.C.im ^ 2 by { have := setup.hC; norm_num [ Complex.normSq, Complex.norm_def ] at this; nlinarith } ] ; ring;
    -- Substitute the expressions for the distances into the equation we need to prove.
    have h_eq : t * (1 - t) * (dist setup.B setup.C)^2 = 1 - (Real.sqrt (1 - t * (1 - t) * (dist setup.B setup.C)^2))^2 := by
      rw [ Real.sq_sqrt ] <;> norm_num [ dist_eq_norm ];
      -- Since $B$ and $C$ are on the unit circle, we have $\|B - C\| \leq 2$.
      have h_norm_BC : ‖setup.B - setup.C‖ ≤ 2 := by
        exact le_trans ( norm_sub_le _ _ ) ( by linarith [ setup.hB, setup.hC ] );
      exact le_trans ( mul_le_mul_of_nonneg_left ( pow_le_pow_left₀ ( norm_nonneg _ ) h_norm_BC 2 ) ( mul_nonneg ht.1 ( sub_nonneg.2 ht.2.1 ) ) ) ( by nlinarith only [ sq_nonneg ( t - 1 / 2 ), ht.1, ht.2.1 ] );
    convert h_eq using 1 <;> push_cast [ h_dist_KB, h_dist_KC, h_dist_OK ] <;> ring

/-
1 minus the square of the distance OK is equal to half the square of the norm of P.
-/
lemma one_sub_OK_sq_eq_half_OP_sq (setup : ProblemSetup) :
  1 - (dist setup.K 0)^2 = 1/2 * (norm setup.P)^2 := by
    -- By combining the results from BK_mul_KC_eq_one_sub_OK_sq and h_power, we can conclude the proof.
    have h_combined : dist setup.K setup.B * dist setup.K setup.C = 1 - (dist setup.K 0)^2 ∧ dist setup.K setup.B * dist setup.K setup.C = (1 / 2) * (norm setup.P)^2 := by
      -- Apply the lemma BK_mul_KC_eq_one_sub_OK_sq to get the first equality.
      apply And.intro (BK_mul_KC_eq_one_sub_OK_sq setup) (setup.h_power);
    linarith

/-
If K is the origin, then the norm of P is sqrt(2).
-/
lemma OP_eq_sqrt2_of_K_eq_O (setup : ProblemSetup) (h : setup.K = 0) :
  norm setup.P = Real.sqrt 2 := by
    have := one_sub_OK_sq_eq_half_OP_sq setup;
    rw [ eq_comm, Real.sqrt_eq_iff_mul_self_eq ] <;> norm_num [ h ] at this ⊢ ; linarith

/-
There exists a point L such that B, C, L are collinear and P, A, K, D, L are concyclic.
-/
lemma exists_L_concyclic (setup : ProblemSetup) :
  ∃ L : ℂ, Collinear ℝ {setup.B, setup.C, L} ∧ Concyclic {setup.P, setup.A, setup.K, setup.D, L} := by
    -- We can use the fact that if the endpoints of a segment are not equal, then the segment is itself a valid line.
    use setup.K;
    aesop;
    · obtain ⟨ t, ht₀, ht₁, ht₂ ⟩ := setup.hK_on_segment;
      rw [ collinear_iff_exists_forall_eq_smul_vadd ];
      aesop;
      exact ⟨ setup.B, setup.C - setup.B, ⟨ 0, by norm_num ⟩, ⟨ 1, by norm_num ⟩, ⟨ t, by ring ⟩ ⟩;
    · convert setup.h_concyclic using 1;
      grind

/-
The norm of P is not equal to 1.
-/
lemma P_not_on_circle (setup : ProblemSetup) : norm setup.P ≠ 1 := by
  -- Since P is the intersection of lines BA and CD, and A, B, C, D are distinct points on the unit circle, P cannot be A or B.
  have hP_ne_A_B : setup.P ≠ setup.A ∧ setup.P ≠ setup.B := by
    refine ⟨ setup.hP_not_A, ?_ ⟩;
    -- Since $P$ is the intersection of lines $BA$ and $CD$, and $A$, $B$, $C$, $D$ are distinct points on the unit circle, $P$ cannot be $B$.
    by_contra hP_eq_B;
    -- Since $P$ is the intersection of lines $BA$ and $CD$, and $A$, $B$, $C$, $D$ are distinct points on the unit circle, $P$ cannot be $B$. This contradicts our assumption.
    have h_contra : Collinear ℝ {setup.B, setup.C, setup.D} := by
      have h_contradiction : Collinear ℝ {setup.P, setup.C, setup.D} := by
        exact setup.hP_collinear_CD;
      aesop;
    simp_all +decide [ collinear_iff_exists_forall_eq_smul_vadd ];
    obtain ⟨ p₀, v, ⟨ r₁, hr₁ ⟩, ⟨ r₂, hr₂ ⟩, ⟨ r₃, hr₃ ⟩ ⟩ := h_contra;
    have := setup.h_angle_ABC; have := setup.h_angle_BCD; simp_all +decide [ EuclideanGeometry.angle ];
    -- Since the vectors (r₁ * v - r₂ * v) and (r₃ * v - r₂ * v) are collinear, their angle must be 0 or π.
    have h_angle_zero_or_pi : InnerProductGeometry.angle ((r₁ * v - r₂ * v) : ℂ) ((r₃ * v - r₂ * v) : ℂ) = 0 ∨ InnerProductGeometry.angle ((r₁ * v - r₂ * v) : ℂ) ((r₃ * v - r₂ * v) : ℂ) = Real.pi := by
      rw [ InnerProductGeometry.angle ];
      by_cases h : r₁ * v - r₂ * v = 0 <;> by_cases h' : r₃ * v - r₂ * v = 0 <;> simp_all +decide [ Complex.ext_iff, mul_sub ];
      norm_num [ Complex.normSq, Complex.norm_def ];
      rw [ le_div_iff₀, div_le_iff₀ ];
      · rw [ ← Real.sqrt_mul <| by nlinarith ];
        exact Classical.or_iff_not_imp_left.2 fun h => by nlinarith [ Real.sqrt_nonneg ( ( ( r₁ * v.re - r₂ * v.re ) * ( r₁ * v.re - r₂ * v.re ) + ( r₁ * v.im - r₂ * v.im ) * ( r₁ * v.im - r₂ * v.im ) ) * ( ( r₃ * v.re - r₂ * v.re ) * ( r₃ * v.re - r₂ * v.re ) + ( r₃ * v.im - r₂ * v.im ) * ( r₃ * v.im - r₂ * v.im ) ) ), Real.mul_self_sqrt ( by nlinarith : 0 ≤ ( ( r₁ * v.re - r₂ * v.re ) * ( r₁ * v.re - r₂ * v.re ) + ( r₁ * v.im - r₂ * v.im ) * ( r₁ * v.im - r₂ * v.im ) ) * ( ( r₃ * v.re - r₂ * v.re ) * ( r₃ * v.re - r₂ * v.re ) + ( r₃ * v.im - r₂ * v.im ) * ( r₃ * v.im - r₂ * v.im ) ) ) ] ;
      · exact mul_pos ( Real.sqrt_pos.mpr ( not_le.mp fun h'' => h ( by nlinarith ) ( by nlinarith ) ) ) ( Real.sqrt_pos.mpr ( not_le.mp fun h'' => h' ( by nlinarith ) ( by nlinarith ) ) );
      · exact mul_pos ( Real.sqrt_pos.mpr ( not_le.mp fun h'' => h ( by nlinarith ) ( by nlinarith ) ) ) ( Real.sqrt_pos.mpr ( not_le.mp fun h'' => h' ( by nlinarith ) ( by nlinarith ) ) );
    cases h_angle_zero_or_pi <;> linarith [ Real.pi_pos, InnerProductGeometry.angle_nonneg ( setup.A - ( r₁ * v + p₀ ) ) ( r₂ * v - r₁ * v ) ];
  -- Since P lies on line BA, we have P = A + t • (B - A) for some real t.
  obtain ⟨t, ht⟩ : ∃ t : ℝ, setup.P = setup.A + t • (setup.B - setup.A) := by
    -- Since P lies on line BA, we have P = A + t • (B - A) for some real t. This follows from the definition of collinearity.
    have hP_on_line_AB : Collinear ℝ {setup.A, setup.B, setup.P} := by
      have := setup.hP_collinear_AB;
      unfold collinear_complex at this; aesop;
      rw [ collinear_iff_exists_forall_eq_smul_vadd ] at * ; aesop;
    rw [ collinear_iff_exists_forall_eq_smul_vadd ] at hP_on_line_AB;
    norm_num +zetaDelta at *;
    -- By definition of collinearity, we can express setup.P in terms of setup.A and setup.B using the coefficients from hP_on_line_AB.
    obtain ⟨p₀, v, ⟨r₁, hr₁⟩, ⟨r₂, hr₂⟩, ⟨r₃, hr₃⟩⟩ := hP_on_line_AB;
    use (r₃ - r₁) / (r₂ - r₁);
    field_simp [hr₁, hr₂, hr₃];
    by_cases h : r₂ = r₁ <;> simp_all +decide [ sub_eq_iff_eq_add ];
    · have := setup.h_angle_ABC; simp_all +decide [ EuclideanGeometry.angle ] ;
      have := setup.h_angle_BCD; simp_all +decide [ EuclideanGeometry.angle ] ;
      linarith;
    · -- Combine like terms and simplify the expression.
      field_simp [sub_ne_zero.mpr (by aesop : (r₂ : ℂ) ≠ r₁)]
      ring;
  by_cases hA : t = 0 <;> by_cases hB : t = 1 <;> simp_all +decide [ Complex.norm_def, Complex.normSq ];
  have := setup.hA; have := setup.hB; simp_all +decide [ Complex.normSq, Complex.norm_def ] ; ring_nf at *; aesop;
  rw [ show setup.A.im ^ 2 = 1 - setup.A.re ^ 2 by linarith, show setup.B.im ^ 2 = 1 - setup.B.re ^ 2 by linarith ] at a ; ring_nf at a ; simp_all +decide [ Complex.ext_iff ] ;
  grind

/-
L is a point such that B, C, L are collinear and P, A, K, D, L are concyclic.
-/
def L_point (setup : ProblemSetup) : ℂ :=
  Classical.choose (exists_L_concyclic setup)

/-
L is a point such that B, C, L are collinear and P, A, K, D, L are concyclic.
-/
lemma L_properties (setup : ProblemSetup) :
  Collinear ℝ {setup.B, setup.C, L_point setup} ∧ Concyclic {setup.P, setup.A, setup.K, setup.D, L_point setup} :=
  Classical.choose_spec (exists_L_concyclic setup)