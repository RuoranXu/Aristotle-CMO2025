/-
Sorry, Aristotle was unable to complete the task in time.
-/
/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
-/

import Mathlib

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Definition of a valid triple (a, b, c) for a given n.
-/
def is_valid_triple (n : ℕ) (a b c : ZMod n) : Prop :=
  Nat.gcd a.val (Nat.gcd b.val (Nat.gcd c.val n)) = 1 ∧
  ∃ σ : Equiv.Perm (ZMod n), ∀ i : ZMod n, a * σ (i + 2) + b * σ (i + 1) + c * σ i = 0

/-
The set of triples (k, -2k, k) with k coprime to n are valid triples.
-/
def valid_n (n : ℕ) : Prop :=
  0 < n ∧ n % 2 = 1 ∧ ∀ p : ℕ, p.Prime → p ∣ n → Nat.gcd (p - 1) n = 1

def solution_set (n : ℕ) : Set (ZMod n × ZMod n × ZMod n) :=
  { t | ∃ k : ZMod n, IsUnit k ∧ t.1 = k ∧ t.2.1 = -2 * k ∧ t.2.2 = k }

theorem solution_subset_valid (n : ℕ) (h : valid_n n) :
  solution_set n ⊆ { t | is_valid_triple n t.1 t.2.1 t.2.2 } := by
    -- Let's unfold the definition of `solution_set`.
    unfold solution_set is_valid_triple; intro t ht; aesop;
    · cases left ; aesop;
      -- Since $w$ is a unit modulo $n$, we have $\gcd(w.val, n) = 1$.
      have h_unit : Nat.gcd (w.val.val) n = 1 := by
        exact?;
      simp_all +decide [ Nat.gcd_assoc ];
    · use 1; aesop; ring;

/-
If a permutation x satisfies b*x_{i+1} + c*x_i = 0 mod n, and p is a prime dividing n, then p must divide b.
-/
lemma prime_dvd_b_of_recurrence_zero {n : ℕ} (p : ℕ) (hp : p.Prime) (hpn : p ∣ n) (b c : ZMod n) (x : ZMod n → ZMod n) (h_perm : Function.Bijective x) (h_rec : ∀ i, (b * x (i + 1) + c * x i : ZMod n) = 0) : p ∣ b.val := by
  cases n <;> aesop;
  · have := h_perm.2 0; aesop;
    have := h_rec w; have := h_perm.2 1; aesop;
    exact absurd ( h_perm.injective ( h_3.trans h.symm ) ) ( by simp +decide [ h_3, h ] );
  · -- Let $y_i = x_i \mod p$. Then $y_i$ is a permutation of $\{0, 1, ..., p-1\}$.
    set y : ZMod (n + 1) → ZMod p := fun i => (x i).val;
    -- Since $x$ is a permutation of $\{0, 1, ..., n\}$, $y_i$ is a permutation of $\{0, 1, ..., p-1\}$.
    have hy_perm : Function.Surjective y := by
      intro k; replace h_perm := congr_arg Multiset.toFinset h_perm; rw [ Finset.ext_iff ] at h_perm; aesop;
      cases' h_perm ( k.val : ZMod ( n + 1 ) ) with a ha ; use a ; aesop;
      haveI := Fact.mk hp; simp +decide [ ZMod.natCast_zmod_val ] ;
    -- Since $p$ divides $n+1$, we have $b * y (i + 1) + c * y i = 0 \mod p$ for all $i$.
    have h_rec_y : ∀ i : ZMod (n + 1), (b.val : ZMod p) * y (i + 1) + (c.val : ZMod p) * y i = 0 := by
      bound;
      replace h_rec := congr_arg ( fun z => z.val : ZMod ( n + 1 ) → ZMod p ) ( h_rec i ) ; aesop;
    -- If $b$ is not divisible by $p$, then $b$ is a unit modulo $p$.
    by_cases hb_unit : IsUnit (b.val : ZMod p);
    · -- If $b$ is a unit modulo $p$, then $y_{i+1} = -b^{-1} * c * y_i \mod p$.
      have h_rec_y_unit : ∀ i : ZMod (n + 1), y (i + 1) = - (b.val : ZMod p)⁻¹ * (c.val : ZMod p) * y i := by
        haveI := Fact.mk hp; simp_all +decide [ ← eq_sub_iff_add_eq', mul_assoc ] ;
      -- Since $y$ is a permutation of $\{0, 1, ..., p-1\}$, there exists some $k$ such that $y k = 0$.
      obtain ⟨k, hk⟩ : ∃ k : ZMod (n + 1), y k = 0 := by
        exact hy_perm 0;
      -- By induction, we have $y (k + m) = 0$ for all $m$.
      have h_rec_y_zero : ∀ m : ℕ, y (k + m) = 0 := by
        intro m; induction m <;> simp_all +decide [ ← add_assoc ] ;
      -- Since $y$ is a permutation of $\{0, 1, ..., p-1\}$, there exists some $j$ such that $y j = 1$.
      obtain ⟨j, hj⟩ : ∃ j : ZMod (n + 1), y j = 1 := by
        exact hy_perm 1;
      specialize h_rec_y_zero ( j - k |> ZMod.val ) ; aesop;
      rcases p with ( _ | _ | p ) <;> cases h_rec_y_zero ; contradiction;
    · haveI := Fact.mk hp; simp_all +decide [ ← ZMod.natCast_eq_zero_iff ] ;

/-
If a sequence y indexed by ZMod n satisfies y_{i+1} = k y_i in ZMod p and takes the value 0, then it is identically 0.
-/
lemma geometric_progression_zero_cyclic {n : ℕ} {p : ℕ} (hp : p.Prime) (k : ZMod p) (y : ZMod n → ZMod p) (h_rec : ∀ i, y (i + 1) = k * y i) (h_zero : ∃ i, y i = 0) : ∀ i, y i = 0 := by
  obtain ⟨x, hx⟩ : ∃ x : ZMod n, y x = 0 := h_zero;
  by_cases hn : n = 0;
  · aesop;
    have h_seq_zero : ∀ m : ℕ, y (x + m) = 0 := by
      intro m; induction m <;> simp_all +decide [ ← add_assoc ] ;
    have h_seq_zero_neg : ∀ m : ℕ, y (x - m) = 0 := by
      intro m; induction m <;> aesop;
      have := h_rec ( x - ( n + 1 ) ) ; ring_nf at *; aesop;
      specialize h_rec ( -1 + ( x - n ) - 1 ) ; ring_nf at * ; aesop;
      haveI := Fact.mk hp; aesop;
    cases' Int.eq_nat_or_neg ( i - x ) with h h ; aesop;
    · simpa [ sub_eq_iff_eq_add'.mp h_2 ] using h_seq_zero h_1;
    · convert h_seq_zero_neg h_1 using 1 ; rw [ sub_eq_iff_eq_add.mp h_3 ] ; ring;
  · haveI := Fact.mk hp;
    -- If y(x) = 0, then by induction, y(x + m) = 0 for all m.
    have h_ind : ∀ m : ℕ, y (x + m) = 0 := by
      intro m; induction m <;> simp_all +decide [ ← add_assoc ] ;
    intro i; specialize h_ind ( ( i - x ) |> ZMod.val ) ; aesop;
    cases n <;> aesop

/-
If b*x_{i+1} + c*x_i = 0 mod p for a permutation x, then p divides b.
-/
lemma prime_dvd_b_of_recurrence_mod_p {n : ℕ} (p : ℕ) (hp : p.Prime) (hpn : p ∣ n) (b c : ZMod n) (x : ZMod n → ZMod n) (h_perm : Function.Bijective x) (h_rec : ∀ i, (b.val * (x (i + 1)).val + c.val * (x i).val) % p = 0) : p ∣ b.val := by
  -- Assume for contradiction that p does not divide b.val.
  by_contra h_not_div;
  -- Then b is a unit modulo p.
  have h_unit : IsUnit (b.val : ZMod p) := by
    haveI := Fact.mk hp; exact IsUnit.mk0 _ ( by rwa [ ← ZMod.natCast_eq_zero_iff ] at h_not_div ) ;
  -- Let y : ZMod n -> ZMod p be defined by y i = (x i).val % p.
  set y : ZMod n → ZMod p := fun i => (x i).val;
  -- The recurrence condition implies y_{i+1} = -b^{-1} * c * y_i.
  have h_recurrence : ∀ i, y (i + 1) = -h_unit.unit⁻¹.val * c.val * y i := by
    haveI := Fact.mk hp; simp_all +decide [ ← ZMod.val_natCast, Nat.add_mod, Nat.mul_mod ] ;
    intro i; have := h_rec i; rw [ ← eq_sub_iff_add_eq' ] at this; aesop;
    simp_all +decide [ mul_assoc, mul_comm, mul_left_comm ];
  -- Since x is a permutation, there exists k such that x k = 0.
  obtain ⟨k, hk⟩ : ∃ k : ZMod n, x k = 0 := by
    exact h_perm.surjective 0;
  -- Since y is a geometric progression with ratio -b^{-1} * c and y k = 0, we have y i = 0 for all i.
  have h_y_zero : ∀ i : ZMod n, y i = 0 := by
    -- By the lemma geometric_progression_zero_cyclic, y i = 0 for all i.
    apply geometric_progression_zero_cyclic hp (-h_unit.unit⁻¹.val * c.val) y;
    · assumption;
    · exact ⟨ k, by aesop ⟩;
  simp +zetaDelta at *;
  have := h_perm.2 1; obtain ⟨ i, hi ⟩ := this; specialize h_y_zero i; simp_all +decide [ ZMod.natCast_eq_zero_iff ] ;
  rcases n with ( _ | _ | n ) <;> simp_all +decide [ ZMod.val ]

/-
If b*x_{i+1} + c*x_i = 0 mod p and p|b, then p|c.
-/
lemma prime_dvd_c_of_dvd_b {n : ℕ} {p : ℕ} (hp : p.Prime) (hpn : p ∣ n) (b c : ZMod n) (x : ZMod n → ZMod n) (h_perm : Function.Bijective x) (h_rec : ∀ i, (b.val * (x (i + 1)).val + c.val * (x i).val) % p = 0) (hpb : p ∣ b.val) : p ∣ c.val := by
  -- Since x is a permutation, there exists some i such that x i = 1.
  obtain ⟨i, hi⟩ : ∃ i, x i = 1 := by
    exact h_perm.surjective 1;
  -- Substitute i into the recurrence relation h_rec.
  have h_sub : (b.val * (x (i + 1)).val + c.val * 1) % p = 0 := by
    -- Substitute i into the recurrence relation h_rec and use the fact that x i = 1.
    specialize h_rec i;
    aesop;
    -- Since $ZMod.val 1 = 1$, we can simplify the expression in $h_rec$.
    convert h_rec using 1;
    rcases n with ( _ | _ | n ) <;> norm_num [ ZMod.val ] at *;
  simp_all +decide [ Nat.dvd_iff_mod_eq_zero, Nat.add_mod, Nat.mul_mod ]

/-
The recurrence projected to ZMod p holds, and the term with 'a' vanishes.
-/
lemma recurrence_proj_p {n : ℕ} {p : ℕ} (hpn : p ∣ n) (a b c : ZMod n) (hpa : p ∣ a.val) (x : ZMod n → ZMod n) (h_rec : ∀ i, a * x (i + 2) + b * x (i + 1) + c * x i = 0) :
  ∀ i, (ZMod.castHom hpn (ZMod p) b) * (ZMod.castHom hpn (ZMod p) (x (i + 1))) + (ZMod.castHom hpn (ZMod p) c) * (ZMod.castHom hpn (ZMod p) (x i)) = 0 := by
    -- Since $p \mid a.val$, we have $ZMod.castHom hpn (ZMod p) a = 0$.
    have ha_cast_zero : ZMod.castHom hpn (ZMod p) a = 0 := by
      -- Since $p \mid a.val$, we have $a.val \equiv 0 \pmod{p}$, which implies that the cast of $a$ to $ZMod p$ is $0$.
      have ha_cast_zero : (a.val : ZMod p) = 0 := by
        exact?;
      cases n <;> aesop;
      cases a ; aesop;
      · cases p <;> aesop;
      · simp_all +decide [ ZMod.val, ZMod.cast ];
    intros i; specialize h_rec i; replace h_rec := congr_arg ( ZMod.castHom hpn ( ZMod p ) ) h_rec; aesop;